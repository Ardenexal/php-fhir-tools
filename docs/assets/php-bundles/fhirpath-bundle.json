{
    "component": "FHIRPath",
    "fileCount": 91,
    "files": {
        "/fhir/Component/FHIRPath/src/Cache/ExpressionCacheInterface.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Cache;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Service\\CompiledExpression;\n\n/**\n * Interface for FHIRPath expression caching.\n *\n * Provides a contract for caching compiled FHIRPath expressions to improve\n * performance by avoiding re-parsing of frequently used expressions.\n *\n * @author Ardenexal\n */\ninterface ExpressionCacheInterface\n{\n    /**\n     * Check if an expression is cached.\n     *\n     * @param string $expression The expression string\n     *\n     * @return bool True if the expression is cached\n     */\n    public function has(string $expression): bool;\n\n    /**\n     * Get a cached compiled expression.\n     *\n     * @param string $expression The expression string\n     *\n     * @return CompiledExpression|null The cached expression or null if not found\n     */\n    public function get(string $expression): ?CompiledExpression;\n\n    /**\n     * Store a compiled expression in the cache.\n     *\n     * @param string             $expression The expression string\n     * @param CompiledExpression $compiled   The compiled expression\n     */\n    public function set(string $expression, CompiledExpression $compiled): void;\n\n    /**\n     * Remove an expression from the cache.\n     *\n     * @param string $expression The expression string\n     */\n    public function delete(string $expression): void;\n\n    /**\n     * Clear all cached expressions.\n     */\n    public function clear(): void;\n\n    /**\n     * Get cache statistics.\n     *\n     * @return array{hits: int, misses: int, size: int} Cache statistics\n     */\n    public function getStats(): array;\n}\n",
        "/fhir/Component/FHIRPath/src/Cache/InMemoryExpressionCache.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Cache;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Service\\CompiledExpression;\n\n/**\n * In-memory cache for compiled FHIRPath expressions.\n *\n * Provides a simple, fast in-memory cache with LRU (Least Recently Used) eviction\n * when the cache reaches its maximum size. Tracks cache hits and misses for monitoring.\n *\n * @author Ardenexal\n */\nclass InMemoryExpressionCache implements ExpressionCacheInterface\n{\n    /**\n     * @var array<string, CompiledExpression>\n     */\n    private array $cache = [];\n\n    /**\n     * @var array<string, int>\n     */\n    private array $accessTimes = [];\n\n    private int $hits = 0;\n\n    private int $misses = 0;\n\n    private int $accessCounter = 0;\n\n    /**\n     * Create a new in-memory cache.\n     *\n     * @param int $maxSize Maximum number of expressions to cache (default: 100)\n     */\n    public function __construct(\n        private readonly int $maxSize = 100\n    ) {\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function has(string $expression): bool\n    {\n        return isset($this->cache[$expression]);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function get(string $expression): ?CompiledExpression\n    {\n        if (! isset($this->cache[$expression])) {\n            ++$this->misses;\n\n            return null;\n        }\n\n        ++$this->hits;\n        $this->accessTimes[$expression] = ++$this->accessCounter;\n\n        return $this->cache[$expression];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function set(string $expression, CompiledExpression $compiled): void\n    {\n        // If cache is full, remove least recently used entry\n        if (count($this->cache) >= $this->maxSize && ! isset($this->cache[$expression])) {\n            $this->evictLeastRecentlyUsed();\n        }\n\n        $this->cache[$expression]       = $compiled;\n        $this->accessTimes[$expression] = ++$this->accessCounter;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function delete(string $expression): void\n    {\n        unset($this->cache[$expression], $this->accessTimes[$expression]);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function clear(): void\n    {\n        $this->cache         = [];\n        $this->accessTimes   = [];\n        $this->hits          = 0;\n        $this->misses        = 0;\n        $this->accessCounter = 0;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getStats(): array\n    {\n        return [\n            'hits'   => $this->hits,\n            'misses' => $this->misses,\n            'size'   => count($this->cache),\n        ];\n    }\n\n    /**\n     * Get the cache hit rate as a percentage.\n     *\n     * @return float Hit rate (0-100)\n     */\n    public function getHitRate(): float\n    {\n        $total = $this->hits + $this->misses;\n\n        if ($total === 0) {\n            return 0.0;\n        }\n\n        return ($this->hits / $total) * 100;\n    }\n\n    /**\n     * Get the maximum cache size.\n     *\n     * @return int Maximum number of cached expressions\n     */\n    public function getMaxSize(): int\n    {\n        return $this->maxSize;\n    }\n\n    /**\n     * Evict the least recently used entry from the cache.\n     */\n    private function evictLeastRecentlyUsed(): void\n    {\n        if (empty($this->accessTimes)) {\n            return;\n        }\n\n        $lruExpression = array_key_first($this->accessTimes);\n        $lruTime       = PHP_INT_MAX;\n\n        foreach ($this->accessTimes as $expression => $time) {\n            if ($time < $lruTime) {\n                $lruTime       = $time;\n                $lruExpression = $expression;\n            }\n        }\n\n        $this->delete($lruExpression);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Evaluator/Collection.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator;\n\n/**\n * Immutable collection abstraction for FHIRPath evaluation\n *\n * FHIRPath treats all values as collections (empty, single, or multiple items).\n * This class provides an immutable collection implementation with common operations.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n *\n * @implements \\IteratorAggregate<int, mixed>\n */\nfinal readonly class Collection implements \\IteratorAggregate, \\Countable\n{\n    /**\n     * @param array<int, mixed> $items\n     */\n    private function __construct(\n        private array $items\n    ) {\n    }\n\n    /**\n     * Create an empty collection\n     */\n    public static function empty(): self\n    {\n        return new self([]);\n    }\n\n    /**\n     * Create a collection with a single item\n     */\n    public static function single(mixed $item): self\n    {\n        return new self([$item]);\n    }\n\n    /**\n     * Create a collection from an array of items\n     *\n     * @param array<int, mixed> $items\n     */\n    public static function from(array $items): self\n    {\n        return new self(array_values($items));\n    }\n\n    /**\n     * Check if the collection is empty\n     */\n    public function isEmpty(): bool\n    {\n        return count($this->items) === 0;\n    }\n\n    /**\n     * Check if the collection has exactly one item\n     */\n    public function isSingle(): bool\n    {\n        return count($this->items) === 1;\n    }\n\n    /**\n     * Get the number of items in the collection\n     */\n    public function count(): int\n    {\n        return count($this->items);\n    }\n\n    /**\n     * Get the first item in the collection, or null if empty\n     */\n    public function first(): mixed\n    {\n        return $this->items[0] ?? null;\n    }\n\n    /**\n     * Get the last item in the collection, or null if empty\n     */\n    public function last(): mixed\n    {\n        $count = count($this->items);\n\n        return $count > 0 ? $this->items[$count - 1] : null;\n    }\n\n    /**\n     * Get an item by index, or null if out of bounds\n     */\n    public function get(int $index): mixed\n    {\n        return $this->items[$index] ?? null;\n    }\n\n    /**\n     * Get all items as an array\n     *\n     * @return array<int, mixed>\n     */\n    public function toArray(): array\n    {\n        return $this->items;\n    }\n\n    /**\n     * Map items to a new collection using a callback\n     *\n     * @param callable(mixed): mixed $callback\n     */\n    public function map(callable $callback): self\n    {\n        return new self(array_map($callback, $this->items));\n    }\n\n    /**\n     * Filter items using a predicate callback\n     *\n     * @param callable(mixed): bool $predicate\n     */\n    public function filter(callable $predicate): self\n    {\n        return new self(array_values(array_filter($this->items, $predicate)));\n    }\n\n    /**\n     * Perform a union with another collection (combines items, removes duplicates)\n     */\n    public function union(self $other): self\n    {\n        return new self(array_values(array_unique([...$this->items, ...$other->items], SORT_REGULAR)));\n    }\n\n    /**\n     * Perform an intersection with another collection (keeps only common items)\n     */\n    public function intersect(self $other): self\n    {\n        return new self(array_values(array_intersect($this->items, $other->items)));\n    }\n\n    /**\n     * Concatenate with another collection (combines items, allows duplicates)\n     */\n    public function concat(self $other): self\n    {\n        return new self([...$this->items, ...$other->items]);\n    }\n\n    /**\n     * Check if all items satisfy a predicate\n     *\n     * @param callable(mixed): bool $predicate\n     */\n    public function all(callable $predicate): bool\n    {\n        foreach ($this->items as $item) {\n            if (!$predicate($item)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if any item satisfies a predicate\n     *\n     * @param callable(mixed): bool $predicate\n     */\n    public function any(callable $predicate): bool\n    {\n        foreach ($this->items as $item) {\n            if ($predicate($item)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Flatten a collection of collections into a single collection\n     *\n     * If any item is a Collection, its items are extracted. Non-Collection items\n     * are included as-is.\n     */\n    public function flatten(): self\n    {\n        $result = [];\n        foreach ($this->items as $item) {\n            if ($item instanceof self) {\n                $result = [...$result, ...$item->items];\n            } else {\n                $result[] = $item;\n            }\n        }\n\n        return new self($result);\n    }\n\n    /**\n     * Get an iterator for the collection\n     *\n     * @return \\Traversable<int, mixed>\n     */\n    public function getIterator(): \\Traversable\n    {\n        return new \\ArrayIterator($this->items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Evaluator/EvaluationContext.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator;\n\n/**\n * Context for FHIRPath expression evaluation\n *\n * Maintains state during evaluation including the root resource,\n * current evaluation node, variables, and external constants.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class EvaluationContext\n{\n    /**\n     * @param array<string, mixed> $variables         Variable storage ($this, $index, $total)\n     * @param array<string, mixed> $externalConstants External constants (%)\n     */\n    public function __construct(\n        private mixed $rootResource = null,\n        private mixed $currentNode = null,\n        private array $variables = [],\n        private array $externalConstants = [],\n        private ?FHIRPathEvaluator $evaluator = null\n    ) {\n    }\n\n    /**\n     * Get the root resource being evaluated\n     */\n    public function getRootResource(): mixed\n    {\n        return $this->rootResource;\n    }\n\n    /**\n     * Set the root resource\n     */\n    public function setRootResource(mixed $resource): void\n    {\n        $this->rootResource = $resource;\n    }\n\n    /**\n     * Get the evaluator\n     */\n    public function getEvaluator(): ?FHIRPathEvaluator\n    {\n        return $this->evaluator;\n    }\n\n    /**\n     * Set the evaluator\n     */\n    public function setEvaluator(FHIRPathEvaluator $evaluator): void\n    {\n        $this->evaluator = $evaluator;\n    }\n\n    /**\n     * Get the current evaluation node\n     */\n    public function getCurrentNode(): mixed\n    {\n        return $this->currentNode;\n    }\n\n    /**\n     * Create a new context with a different current node\n     */\n    public function withCurrentNode(mixed $node): self\n    {\n        return new self(\n            $this->rootResource,\n            $node,\n            $this->variables,\n            $this->externalConstants,\n            $this->evaluator,\n        );\n    }\n\n    /**\n     * Set the current node (for mutable context)\n     */\n    public function setCurrentNode(mixed $node): void\n    {\n        $this->currentNode = $node;\n    }\n\n    /**\n     * Get a variable value\n     */\n    public function getVariable(string $name): mixed\n    {\n        return $this->variables[$name] ?? null;\n    }\n\n    /**\n     * Set a variable value\n     */\n    public function setVariable(string $name, mixed $value): void\n    {\n        $this->variables[$name] = $value;\n    }\n\n    /**\n     * Check if a variable exists\n     */\n    public function hasVariable(string $name): bool\n    {\n        return array_key_exists($name, $this->variables);\n    }\n\n    /**\n     * Create a new context with an additional variable\n     */\n    public function withVariable(string $name, mixed $value): self\n    {\n        $variables        = $this->variables;\n        $variables[$name] = $value;\n\n        return new self(\n            $this->rootResource,\n            $this->currentNode,\n            $variables,\n            $this->externalConstants,\n            $this->evaluator,\n        );\n    }\n\n    /**\n     * Get an external constant value\n     */\n    public function getExternalConstant(string $name): mixed\n    {\n        return $this->externalConstants[$name] ?? null;\n    }\n\n    /**\n     * Set an external constant value\n     */\n    public function setExternalConstant(string $name, mixed $value): void\n    {\n        $this->externalConstants[$name] = $value;\n    }\n\n    /**\n     * Check if an external constant exists\n     */\n    public function hasExternalConstant(string $name): bool\n    {\n        return array_key_exists($name, $this->externalConstants);\n    }\n\n    /**\n     * Create a new context with an additional external constant\n     */\n    public function withExternalConstant(string $name, mixed $value): self\n    {\n        $externalConstants        = $this->externalConstants;\n        $externalConstants[$name] = $value;\n\n        return new self(\n            $this->rootResource,\n            $this->currentNode,\n            $this->variables,\n            $externalConstants,\n            $this->evaluator,\n        );\n    }\n\n    /**\n     * Create a context for evaluating a collection item with iteration variables\n     */\n    public function withIterationVariables(mixed $item, int $index, int $total): self\n    {\n        $variables          = $this->variables;\n        $variables['this']  = $item;\n        $variables['index'] = $index;\n        $variables['total'] = $total;\n\n        return new self(\n            $this->rootResource,\n            $item,\n            $variables,\n            $this->externalConstants,\n            $this->evaluator,\n        );\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Evaluator/FHIRPathEvaluator.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\BinaryOperatorNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\CollectionLiteralNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionVisitor;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExternalConstantNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\FunctionCallNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\IdentifierNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\IndexerNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\LiteralNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\MemberAccessNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\TypeExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\UnaryOperatorNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\TokenType;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function\\FunctionRegistry;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Type\\FHIRTypeResolver;\n\n/**\n * FHIRPath expression evaluator\n *\n * Evaluates parsed FHIRPath expressions (AST) against FHIR resources.\n * Implements the FHIRPath 2.0 specification including collection semantics,\n * empty propagation, and proper operator precedence.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class FHIRPathEvaluator implements ExpressionVisitor\n{\n    private EvaluationContext $context;\n\n    private FHIRTypeResolver $typeResolver;\n\n    public function __construct()\n    {\n        $this->context      = new EvaluationContext();\n        $this->typeResolver = new FHIRTypeResolver();\n    }\n\n    /**\n     * Evaluate an expression against a resource\n     *\n     * @param ExpressionNode         $expression The parsed expression (AST)\n     * @param mixed                  $resource   The FHIR resource or data to evaluate against\n     * @param EvaluationContext|null $context    Optional evaluation context\n     */\n    public function evaluate(ExpressionNode $expression, mixed $resource, ?EvaluationContext $context = null): Collection\n    {\n        $this->context = $context ?? new EvaluationContext();\n        $this->context->setRootResource($resource);\n        $this->context->setVariable('this', $resource);\n        $this->context->setEvaluator($this);\n\n        if ($resource !== null) {\n            $this->context->setCurrentNode($resource);\n        }\n\n        return $expression->accept($this);\n    }\n\n    /**\n     * Visit a literal node\n     */\n    public function visitLiteral(LiteralNode $node): Collection\n    {\n        return Collection::single($node->getValue());\n    }\n\n    /**\n     * Visit an identifier node\n     */\n    public function visitIdentifier(IdentifierNode $node): Collection\n    {\n        $name = $node->getName();\n\n        // Handle reserved identifiers ($this, $index, $total)\n        if (str_starts_with($name, '$')) {\n            $variableName = ltrim($name, '$');\n            if ($this->context->hasVariable($variableName)) {\n                $value = $this->context->getVariable($variableName);\n\n                return $value !== null ? Collection::single($value) : Collection::empty();\n            }\n\n            return Collection::empty();\n        }\n\n        // Navigate from current node\n        $currentNode = $this->context->getCurrentNode();\n        if ($currentNode === null) {\n            return Collection::empty();\n        }\n\n        return $this->navigateProperty($currentNode, $name);\n    }\n\n    /**\n     * Visit a member access node (dot notation)\n     */\n    public function visitMemberAccess(MemberAccessNode $node): Collection\n    {\n        // Evaluate the object expression\n        $objectResult = $node->getObject()->accept($this);\n\n        // If object result is empty, return empty (empty propagation)\n        if ($objectResult->isEmpty()) {\n            return Collection::empty();\n        }\n\n        // Navigate each item in the collection and flatten results\n        $results = [];\n        foreach ($objectResult as $item) {\n            $oldContext    = $this->context;\n            $this->context = $this->context->withCurrentNode($item);\n\n            $memberResult = $node->getMember()->accept($this);\n            $results      = [...$results, ...$memberResult->toArray()];\n\n            $this->context = $oldContext;\n        }\n\n        return Collection::from($results);\n    }\n\n    /**\n     * Visit a function call node\n     */\n    public function visitFunctionCall(FunctionCallNode $node): Collection\n    {\n        // Get the current collection (the input to the function)\n        $input           = $this->context->getCurrentNode();\n        $inputCollection = $input !== null ? $this->wrapValue($input) : Collection::empty();\n\n        // Get the function from the registry\n        $registry = FunctionRegistry::getInstance();\n\n        if (!$registry->has($node->getName())) {\n            throw new EvaluationException(\"Unknown function: {$node->getName()}\", $node->getLine(), $node->getColumn());\n        }\n\n        $function = $registry->get($node->getName());\n\n        // Evaluate parameters - they can be expressions or literals\n        $evaluatedParams = [];\n        foreach ($node->getParameters() as $param) {\n            // Parameters are expression nodes that can be passed as-is to functions\n            // Functions like where(), exists(), all() will evaluate them themselves\n            $evaluatedParams[] = $param;\n        }\n\n        // Execute the function\n        return $function->execute($inputCollection, $evaluatedParams, $this->context);\n    }\n\n    /**\n     * Visit a binary operator node\n     */\n    public function visitBinaryOperator(BinaryOperatorNode $node): Collection\n    {\n        $left  = $node->getLeft()->accept($this);\n        $right = $node->getRight()->accept($this);\n\n        return match ($node->getOperator()) {\n            // Union operator\n            TokenType::PIPE => $left->union($right),\n\n            // Arithmetic operators (require single values)\n            TokenType::PLUS     => $this->evaluateArithmetic($left, $right, fn ($a, $b) => $a + $b),\n            TokenType::MINUS    => $this->evaluateArithmetic($left, $right, fn ($a, $b) => $a - $b),\n            TokenType::MULTIPLY => $this->evaluateArithmetic($left, $right, fn ($a, $b) => $a * $b),\n            TokenType::DIVIDE   => $this->evaluateArithmetic($left, $right, fn ($a, $b) => (float) ($a / $b)),\n            TokenType::DIV      => $this->evaluateArithmetic($left, $right, fn ($a, $b) => intdiv((int) $a, (int) $b)),\n            TokenType::MOD      => $this->evaluateArithmetic($left, $right, fn ($a, $b) => $a % $b),\n\n            // Comparison operators\n            TokenType::EQUALS        => $this->evaluateComparison($left, $right, fn ($a, $b) => $a == $b),\n            TokenType::NOT_EQUALS    => $this->evaluateComparison($left, $right, fn ($a, $b) => $a != $b),\n            TokenType::LESS_THAN     => $this->evaluateComparison($left, $right, fn ($a, $b) => $a < $b),\n            TokenType::GREATER_THAN  => $this->evaluateComparison($left, $right, fn ($a, $b) => $a > $b),\n            TokenType::LESS_EQUAL    => $this->evaluateComparison($left, $right, fn ($a, $b) => $a <= $b),\n            TokenType::GREATER_EQUAL => $this->evaluateComparison($left, $right, fn ($a, $b) => $a >= $b),\n\n            // String concatenation\n            TokenType::AMPERSAND => $this->evaluateStringConcat($left, $right),\n\n            // Logical operators\n            TokenType::AND     => $this->evaluateLogicalAnd($left, $right),\n            TokenType::OR      => $this->evaluateLogicalOr($left, $right),\n            TokenType::XOR     => $this->evaluateLogicalXor($left, $right),\n            TokenType::IMPLIES => $this->evaluateImplies($left, $right),\n\n            // Membership operators (to be fully implemented later)\n            TokenType::IN, TokenType::CONTAINS => throw new EvaluationException(\"Operator '{$node->getOperator()->value}' not yet fully implemented\", $node->getLine(), $node->getColumn()),\n\n            default => throw new EvaluationException(\"Unknown operator: {$node->getOperator()->value}\", $node->getLine(), $node->getColumn()),\n        };\n    }\n\n    /**\n     * Visit a unary operator node\n     */\n    public function visitUnaryOperator(UnaryOperatorNode $node): Collection\n    {\n        $operand = $node->getOperand()->accept($this);\n\n        if ($operand->isEmpty()) {\n            return Collection::empty();\n        }\n\n        if (!$operand->isSingle()) {\n            throw new EvaluationException('Unary operator requires a single value', $node->getLine(), $node->getColumn());\n        }\n\n        $value = $operand->first();\n\n        return match ($node->getOperator()) {\n            TokenType::MINUS => Collection::single(-$value),\n            TokenType::PLUS  => Collection::single(+$value),\n            default          => throw new EvaluationException(\"Unknown unary operator: {$node->getOperator()->value}\", $node->getLine(), $node->getColumn()),\n        };\n    }\n\n    /**\n     * Visit an indexer node\n     */\n    public function visitIndexer(IndexerNode $node): Collection\n    {\n        $collection  = $node->getCollection()->accept($this);\n        $indexResult = $node->getIndex()->accept($this);\n\n        if ($indexResult->isEmpty() || !$indexResult->isSingle()) {\n            return Collection::empty();\n        }\n\n        $index = $indexResult->first();\n        if (!is_int($index)) {\n            return Collection::empty();\n        }\n\n        $item = $collection->get($index);\n\n        return $item !== null ? Collection::single($item) : Collection::empty();\n    }\n\n    /**\n     * Visit a type expression node\n     */\n    public function visitTypeExpression(TypeExpressionNode $node): Collection\n    {\n        // Evaluate the expression to get the collection to check/cast\n        $collection = $node->getExpression()->accept($this);\n        $typeName   = $node->getTypeName();\n        $operator   = $node->getOperator();\n\n        // Handle 'is' operator - type checking\n        if ($operator === TokenType::IS) {\n            // For collections, filter items that match the type\n            $filtered = [];\n            foreach ($collection->toArray() as $item) {\n                if ($this->typeResolver->isOfType($item, $typeName)) {\n                    $filtered[] = $item;\n                }\n            }\n\n            return Collection::from($filtered);\n        }\n\n        // Handle 'as' operator - type casting\n        if ($operator === TokenType::AS) {\n            // For collections, cast each item to the target type\n            $casted = [];\n            foreach ($collection->toArray() as $item) {\n                try {\n                    $casted[] = $this->typeResolver->castToType($item, $typeName);\n                } catch (\\InvalidArgumentException $e) {\n                    // If cast fails, skip the item (FHIRPath semantics)\n                    continue;\n                }\n            }\n\n            return Collection::from($casted);\n        }\n\n        throw new EvaluationException(sprintf('Unsupported type operator: %s', $operator->name), $node->getLine(), $node->getColumn());\n    }\n\n    /**\n     * Visit an external constant node\n     */\n    public function visitExternalConstant(ExternalConstantNode $node): Collection\n    {\n        if ($this->context->hasExternalConstant($node->getName())) {\n            $value = $this->context->getExternalConstant($node->getName());\n\n            return $value !== null ? Collection::single($value) : Collection::empty();\n        }\n\n        throw new EvaluationException(\"External constant '%{$node->getName()}' not found\", $node->getLine(), $node->getColumn());\n    }\n\n    /**\n     * Visit a collection literal node\n     */\n    public function visitCollectionLiteral(CollectionLiteralNode $node): Collection\n    {\n        if (empty($node->getElements())) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($node->getElements() as $itemNode) {\n            $result = $itemNode->accept($this);\n            $items  = [...$items, ...$result->toArray()];\n        }\n\n        return Collection::from($items);\n    }\n\n    /**\n     * Navigate a property on a node\n     */\n    private function navigateProperty(mixed $node, string $propertyName): Collection\n    {\n        // Handle arrays\n        if (is_array($node)) {\n            if (array_key_exists($propertyName, $node)) {\n                $value = $node[$propertyName];\n\n                return $this->wrapValue($value);\n            }\n\n            return Collection::empty();\n        }\n\n        // Handle objects\n        if (is_object($node)) {\n            // Try direct property access\n            if (property_exists($node, $propertyName)) {\n                try {\n                    $value = $node->$propertyName;\n\n                    return $this->wrapValue($value);\n                } catch (\\Error $e) {\n                    // Property exists but is not accessible (e.g., private/protected)\n                    // Fall through to try getter method\n                }\n            }\n\n            // Try getter method\n            $getter = 'get' . ucfirst($propertyName);\n            if (method_exists($node, $getter)) {\n                $value = $node->$getter();\n\n                return $this->wrapValue($value);\n            }\n\n            // Handle polymorphic properties (value[x])\n            // Look for properties like valueString, valueInteger, etc.\n            foreach (get_object_vars($node) as $prop => $value) {\n                if (str_starts_with($prop, $propertyName) && $prop !== $propertyName) {\n                    return $this->wrapValue($value);\n                }\n            }\n\n            return Collection::empty();\n        }\n\n        return Collection::empty();\n    }\n\n    /**\n     * Wrap a value in a collection\n     */\n    private function wrapValue(mixed $value): Collection\n    {\n        if ($value === null) {\n            return Collection::empty();\n        }\n\n        if (is_array($value)) {\n            // Check if it's an associative array (object) or indexed array (collection)\n            if (array_is_list($value)) {\n                return Collection::from($value);\n            }\n\n            return Collection::single($value);\n        }\n\n        return Collection::single($value);\n    }\n\n    /**\n     * Evaluate arithmetic operation\n     *\n     * @param callable(mixed, mixed): mixed $operation\n     */\n    private function evaluateArithmetic(Collection $left, Collection $right, callable $operation): Collection\n    {\n        if ($left->isEmpty() || $right->isEmpty()) {\n            return Collection::empty();\n        }\n\n        if (!$left->isSingle() || !$right->isSingle()) {\n            throw new EvaluationException('Arithmetic operators require single values');\n        }\n\n        $leftValue  = $left->first();\n        $rightValue = $right->first();\n\n        if (!is_numeric($leftValue) || !is_numeric($rightValue)) {\n            return Collection::empty();\n        }\n\n        return Collection::single($operation($leftValue, $rightValue));\n    }\n\n    /**\n     * Evaluate comparison operation\n     *\n     * @param callable(mixed, mixed): bool $operation\n     */\n    private function evaluateComparison(Collection $left, Collection $right, callable $operation): Collection\n    {\n        if ($left->isEmpty() || $right->isEmpty()) {\n            return Collection::empty();\n        }\n\n        if (!$left->isSingle() || !$right->isSingle()) {\n            return Collection::empty();\n        }\n\n        $result = $operation($left->first(), $right->first());\n\n        return Collection::single($result);\n    }\n\n    /**\n     * Evaluate string concatenation\n     */\n    private function evaluateStringConcat(Collection $left, Collection $right): Collection\n    {\n        if ($left->isEmpty() || $right->isEmpty()) {\n            return Collection::empty();\n        }\n\n        if (!$left->isSingle() || !$right->isSingle()) {\n            return Collection::empty();\n        }\n\n        $result = (string) $left->first() . (string) $right->first();\n\n        return Collection::single($result);\n    }\n\n    /**\n     * Evaluate logical AND (three-valued logic)\n     */\n    private function evaluateLogicalAnd(Collection $left, Collection $right): Collection\n    {\n        $leftBool  = $this->toBoolean($left);\n        $rightBool = $this->toBoolean($right);\n\n        // Three-valued logic: false and anything = false\n        if ($leftBool === false || $rightBool === false) {\n            return Collection::single(false);\n        }\n\n        // true and true = true\n        if ($leftBool === true && $rightBool === true) {\n            return Collection::single(true);\n        }\n\n        // Otherwise empty (unknown)\n        return Collection::empty();\n    }\n\n    /**\n     * Evaluate logical OR (three-valued logic)\n     */\n    private function evaluateLogicalOr(Collection $left, Collection $right): Collection\n    {\n        $leftBool  = $this->toBoolean($left);\n        $rightBool = $this->toBoolean($right);\n\n        // Three-valued logic: true or anything = true\n        if ($leftBool === true || $rightBool === true) {\n            return Collection::single(true);\n        }\n\n        // false or false = false\n        if ($leftBool === false && $rightBool === false) {\n            return Collection::single(false);\n        }\n\n        // Otherwise empty (unknown)\n        return Collection::empty();\n    }\n\n    /**\n     * Evaluate logical XOR\n     */\n    private function evaluateLogicalXor(Collection $left, Collection $right): Collection\n    {\n        $leftBool  = $this->toBoolean($left);\n        $rightBool = $this->toBoolean($right);\n\n        if ($leftBool === null || $rightBool === null) {\n            return Collection::empty();\n        }\n\n        $result = ($leftBool xor $rightBool);\n\n        return Collection::single($result);\n    }\n\n    /**\n     * Evaluate logical implication (A implies B = !A or B)\n     */\n    private function evaluateImplies(Collection $left, Collection $right): Collection\n    {\n        $leftBool  = $this->toBoolean($left);\n        $rightBool = $this->toBoolean($right);\n\n        // Three-valued logic for implies\n        // false implies anything = true\n        if ($leftBool === false) {\n            return Collection::single(true);\n        }\n\n        // true implies true = true\n        if ($leftBool === true && $rightBool === true) {\n            return Collection::single(true);\n        }\n\n        // true implies false = false\n        if ($leftBool === true && $rightBool === false) {\n            return Collection::single(false);\n        }\n\n        // Otherwise empty (unknown)\n        return Collection::empty();\n    }\n\n    /**\n     * Convert collection to boolean (three-valued logic)\n     *\n     * @return bool|null true, false, or null (unknown)\n     */\n    private function toBoolean(Collection $collection): ?bool\n    {\n        if ($collection->isEmpty()) {\n            return null;\n        }\n\n        if (!$collection->isSingle()) {\n            return null;\n        }\n\n        $value = $collection->first();\n\n        if (is_bool($value)) {\n            return $value;\n        }\n\n        if ($value === null) {\n            return null;\n        }\n\n        // Other types can't be converted to boolean in FHIRPath\n        return null;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Exception/EvaluationException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception;\n\n/**\n * Exception thrown when evaluating FHIRPath expressions fails.\n *\n * This exception is thrown when:\n * - Type mismatches occur during evaluation\n * - Invalid operations are attempted\n * - Resource navigation fails\n * - Function or operator execution fails\n *\n * @author FHIR Tools Contributors\n */\nclass EvaluationException extends FHIRPathException\n{\n    /**\n     * Create an evaluation exception with detailed error information.\n     *\n     * @param string      $message           The error message\n     * @param int         $line              The line number where evaluation failed\n     * @param int         $column            The column number where evaluation failed\n     * @param string      $expressionContext The expression context around the error\n     * @param string|null $suggestion        Optional suggestion for fixing the error\n     */\n    public function __construct(\n        string $message,\n        int $line = 0,\n        int $column = 0,\n        string $expressionContext = '',\n        ?string $suggestion = null\n    ) {\n        parent::__construct($message, $line, $column, $expressionContext, $suggestion);\n    }\n\n    /**\n     * Create an evaluation exception for type mismatches.\n     *\n     * @param string $expectedType The expected type\n     * @param string $actualType   The actual type found\n     * @param string $context      The expression context\n     */\n    public static function typeMismatch(\n        string $expectedType,\n        string $actualType,\n        string $context = ''\n    ): self {\n        $message = sprintf(\n            'Type mismatch: expected %s but got %s',\n            $expectedType,\n            $actualType,\n        );\n\n        $suggestion = 'Ensure the expression operates on the correct types or use type conversion functions.';\n\n        return new self($message, 0, 0, $context, $suggestion);\n    }\n\n    /**\n     * Create an evaluation exception for invalid operations.\n     *\n     * @param string $operation The operation that failed\n     * @param string $reason    The reason for failure\n     * @param string $context   The expression context\n     */\n    public static function invalidOperation(\n        string $operation,\n        string $reason,\n        string $context = ''\n    ): self {\n        $message = sprintf(\n            'Invalid operation %s: %s',\n            $operation,\n            $reason,\n        );\n\n        $suggestion = 'Check that the operation is applicable to the current data.';\n\n        return new self($message, 0, 0, $context, $suggestion);\n    }\n\n    /**\n     * Create an evaluation exception for navigation failures.\n     *\n     * @param string $path    The path that failed\n     * @param string $reason  The reason for failure\n     * @param string $context The expression context\n     */\n    public static function navigationFailed(\n        string $path,\n        string $reason,\n        string $context = ''\n    ): self {\n        $message = sprintf(\n            'Navigation failed for path \"%s\": %s',\n            $path,\n            $reason,\n        );\n\n        $suggestion = 'Verify that the path exists in the FHIR resource structure.';\n\n        return new self($message, 0, 0, $context, $suggestion);\n    }\n\n    /**\n     * Create an evaluation exception for invalid function parameters.\n     *\n     * @param string $functionName  The function name\n     * @param string $parameterName The parameter name\n     * @param string $expectedType  The expected type/format\n     */\n    public static function invalidFunctionParameter(\n        string $functionName,\n        string $parameterName,\n        string $expectedType\n    ): self {\n        $message = sprintf(\n            \"Function '%s' parameter '%s' must be %s\",\n            $functionName,\n            $parameterName,\n            $expectedType,\n        );\n\n        $suggestion = 'Check the function documentation for the correct parameter types.';\n\n        return new self($message, 0, 0, '', $suggestion);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Exception/FHIRPathException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception;\n\n/**\n * Base exception for all FHIRPath-related errors.\n *\n * @author FHIR Tools Contributors\n */\nclass FHIRPathException extends \\RuntimeException\n{\n    protected int $expressionLine = 0;\n\n    protected int $expressionColumn = 0;\n\n    protected string $expressionContext = '';\n\n    protected ?string $suggestion = null;\n\n    /**\n     * Create a FHIRPath exception.\n     *\n     * @param string      $message           The error message\n     * @param int         $line              The line number where the error occurred in the expression\n     * @param int         $column            The column number where the error occurred in the expression\n     * @param string      $expressionContext The expression context around the error\n     * @param string|null $suggestion        Optional suggestion for fixing the error\n     */\n    public function __construct(\n        string $message,\n        int $line = 0,\n        int $column = 0,\n        string $expressionContext = '',\n        ?string $suggestion = null\n    ) {\n        parent::__construct($message);\n        $this->expressionLine    = $line;\n        $this->expressionColumn  = $column;\n        $this->expressionContext = $expressionContext;\n        $this->suggestion        = $suggestion;\n    }\n\n    /**\n     * Get the line number where the error occurred in the FHIRPath expression.\n     */\n    public function getExpressionLine(): int\n    {\n        return $this->expressionLine;\n    }\n\n    /**\n     * Get the column number where the error occurred in the FHIRPath expression.\n     */\n    public function getExpressionColumn(): int\n    {\n        return $this->expressionColumn;\n    }\n\n    /**\n     * Get the expression context around the error.\n     */\n    public function getExpressionContext(): string\n    {\n        return $this->expressionContext;\n    }\n\n    /**\n     * Get a suggestion for fixing the error.\n     */\n    public function getSuggestion(): ?string\n    {\n        return $this->suggestion;\n    }\n\n    /**\n     * Get the full error message including position and context.\n     */\n    public function getFullMessage(): string\n    {\n        $message = $this->getMessage();\n\n        if ($this->expressionLine > 0) {\n            $message .= sprintf(' at line %d, column %d', $this->expressionLine, $this->expressionColumn);\n        }\n\n        if ($this->expressionContext !== '') {\n            $message .= \"\\nContext: \" . $this->expressionContext;\n        }\n\n        if ($this->suggestion !== null) {\n            $message .= \"\\nSuggestion: \" . $this->suggestion;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Get position information as an array.\n     *\n     * @return array{line: int, column: int}\n     */\n    public function getPosition(): array\n    {\n        return [\n            'line'   => $this->expressionLine,\n            'column' => $this->expressionColumn,\n        ];\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Exception/ParseException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception;\n\n/**\n * Exception thrown when parsing FHIRPath expressions fails.\n *\n * This exception is thrown when:\n * - The expression has invalid syntax\n * - Unexpected tokens are encountered\n * - The expression structure is malformed\n *\n * @author FHIR Tools Contributors\n */\nclass ParseException extends FHIRPathException\n{\n    /**\n     * Create a parse exception with detailed error information.\n     *\n     * @param string      $message           The error message\n     * @param int         $line              The line number where parsing failed\n     * @param int         $column            The column number where parsing failed\n     * @param string      $expressionContext The expression context around the error\n     * @param string|null $suggestion        Optional suggestion for fixing the error\n     */\n    public function __construct(\n        string $message,\n        int $line = 0,\n        int $column = 0,\n        string $expressionContext = '',\n        ?string $suggestion = null\n    ) {\n        parent::__construct($message, $line, $column, $expressionContext, $suggestion);\n    }\n\n    /**\n     * Create a parse exception for an unexpected token.\n     *\n     * @param string $expected The expected token type\n     * @param string $actual   The actual token found\n     * @param int    $line     The line number\n     * @param int    $column   The column number\n     * @param string $context  The expression context\n     */\n    public static function unexpectedToken(\n        string $expected,\n        string $actual,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message = sprintf(\n            'Expected %s but found %s',\n            $expected,\n            $actual,\n        );\n\n        $suggestion = 'Check the expression syntax and ensure all operators and functions are used correctly.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a parse exception for invalid syntax.\n     *\n     * @param string $details Details about the syntax error\n     * @param int    $line    The line number\n     * @param int    $column  The column number\n     * @param string $context The expression context\n     */\n    public static function invalidSyntax(\n        string $details,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Invalid syntax: %s', $details);\n        $suggestion = 'Review the FHIRPath specification for correct syntax.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Exception/SyntaxException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception;\n\n/**\n * Exception thrown when parsing encounters a syntax error.\n *\n * This exception is thrown when:\n * - The parser encounters an unexpected token\n * - The expression structure doesn't match the grammar\n * - Required tokens are missing\n *\n * @author FHIR Tools Contributors\n */\nclass SyntaxException extends ParseException\n{\n    /**\n     * Create a syntax exception for an unexpected token.\n     *\n     * @param string $expected Description of what was expected\n     * @param string $found    Description of what was found\n     * @param int    $line     The line number\n     * @param int    $column   The column number\n     * @param string $context  The expression context\n     */\n    public static function unexpectedToken(\n        string $expected,\n        string $found,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Expected %s but found %s', $expected, $found);\n        $suggestion = 'Check the expression syntax and ensure all parts are correctly formed.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a syntax exception for unexpected end of expression.\n     *\n     * @param string $expected Description of what was expected\n     * @param int    $line     The line number\n     * @param int    $column   The column number\n     * @param string $context  The expression context\n     */\n    public static function unexpectedEnd(\n        string $expected,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Unexpected end of expression; expected %s', $expected);\n        $suggestion = 'Complete the expression or remove incomplete parts.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a syntax exception for invalid expression structure.\n     *\n     * @param string $details Details about the structural error\n     * @param int    $line    The line number\n     * @param int    $column  The column number\n     * @param string $context The expression context\n     */\n    public static function invalidStructure(\n        string $details,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Invalid expression structure: %s', $details);\n        $suggestion = 'Review the FHIRPath grammar and ensure the expression follows the correct structure.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Exception/TokenException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception;\n\n/**\n * Exception thrown when tokenization (lexical analysis) fails.\n *\n * This exception is thrown when:\n * - Invalid characters are encountered\n * - Unterminated string literals are found\n * - Malformed number literals are encountered\n * - Invalid escape sequences are used\n *\n * @author FHIR Tools Contributors\n */\nclass TokenException extends ParseException\n{\n    /**\n     * Create a token exception for unterminated string literals.\n     *\n     * @param int    $line    The line number where the string started\n     * @param int    $column  The column number where the string started\n     * @param string $context The expression context\n     */\n    public static function unterminatedString(\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = 'Unterminated string literal';\n        $suggestion = \"Add a closing quote ' to terminate the string.\";\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a token exception for invalid escape sequences.\n     *\n     * @param string $sequence The invalid escape sequence\n     * @param int    $line     The line number\n     * @param int    $column   The column number\n     * @param string $context  The expression context\n     */\n    public static function invalidEscapeSequence(\n        string $sequence,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Invalid escape sequence: %s', $sequence);\n        $suggestion = \"Use valid escape sequences: \\\\', \\\\\\\", \\\\\\\\, \\\\t, \\\\n, \\\\r, \\\\f, or \\\\uXXXX\";\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a token exception for invalid number formats.\n     *\n     * @param string $value   The invalid number value\n     * @param int    $line    The line number\n     * @param int    $column  The column number\n     * @param string $context The expression context\n     */\n    public static function invalidNumber(\n        string $value,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Invalid number format: %s', $value);\n        $suggestion = 'Use valid number formats: 42, 3.14, or 2.5e10';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a token exception for unexpected characters.\n     *\n     * @param string $char    The unexpected character\n     * @param int    $line    The line number\n     * @param int    $column  The column number\n     * @param string $context The expression context\n     */\n    public static function unexpectedCharacter(\n        string $char,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message = sprintf(\n            'Unexpected character: %s',\n            $char === \"\\0\" ? '<EOF>' : \"'{$char}'\",\n        );\n        $suggestion = 'Check for invalid characters or missing quotes around strings.';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n\n    /**\n     * Create a token exception for invalid datetime literals.\n     *\n     * @param string $value   The invalid datetime value\n     * @param int    $line    The line number\n     * @param int    $column  The column number\n     * @param string $context The expression context\n     */\n    public static function invalidDateTime(\n        string $value,\n        int $line,\n        int $column,\n        string $context = ''\n    ): self {\n        $message    = sprintf('Invalid date/time format: %s', $value);\n        $suggestion = 'Use valid formats: @2023-12-25, @2023-12-25T12:30:00, or @T12:30:00';\n\n        return new self($message, $line, $column, $context, $suggestion);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/BinaryOperatorNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\TokenType;\n\n/**\n * AST node representing a binary operator expression.\n *\n * Represents binary operations in FHIRPath such as addition, comparison,\n * logical operations, etc.\n *\n * @author FHIR Tools Contributors\n */\nclass BinaryOperatorNode extends ExpressionNode\n{\n    /**\n     * Create a new binary operator node.\n     *\n     * @param ExpressionNode $left     The left operand\n     * @param TokenType      $operator The operator\n     * @param ExpressionNode $right    The right operand\n     * @param int            $line     The line number\n     * @param int            $column   The column number\n     */\n    public function __construct(\n        private readonly ExpressionNode $left,\n        private readonly TokenType $operator,\n        private readonly ExpressionNode $right,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the left operand.\n     */\n    public function getLeft(): ExpressionNode\n    {\n        return $this->left;\n    }\n\n    /**\n     * Get the operator.\n     */\n    public function getOperator(): TokenType\n    {\n        return $this->operator;\n    }\n\n    /**\n     * Get the right operand.\n     */\n    public function getRight(): ExpressionNode\n    {\n        return $this->right;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitBinaryOperator($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        $operatorStr = match ($this->operator) {\n            TokenType::AND            => ' and ',\n            TokenType::OR             => ' or ',\n            TokenType::XOR            => ' xor ',\n            TokenType::IMPLIES        => ' implies ',\n            TokenType::EQUALS         => ' = ',\n            TokenType::NOT_EQUALS     => ' != ',\n            TokenType::EQUIVALENT     => ' ~ ',\n            TokenType::NOT_EQUIVALENT => ' !~ ',\n            TokenType::GREATER_THAN   => ' > ',\n            TokenType::LESS_THAN      => ' < ',\n            TokenType::GREATER_EQUAL  => ' >= ',\n            TokenType::LESS_EQUAL     => ' <= ',\n            TokenType::PLUS           => ' + ',\n            TokenType::MINUS          => ' - ',\n            TokenType::MULTIPLY       => ' * ',\n            TokenType::DIVIDE         => ' / ',\n            TokenType::DIV            => ' div ',\n            TokenType::MOD            => ' mod ',\n            TokenType::PIPE           => ' | ',\n            TokenType::AMPERSAND      => ' & ',\n            TokenType::IN             => ' in ',\n            TokenType::CONTAINS       => ' contains ',\n            default                   => ' ' . $this->operator->value . ' ',\n        };\n\n        return '(' . $this->left->toString() . $operatorStr . $this->right->toString() . ')';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/CollectionLiteralNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing a collection literal.\n *\n * Represents explicit collection literals in FHIRPath using brace notation.\n * For example, `{}` (empty collection) or `{1, 2, 3}`.\n *\n * @author FHIR Tools Contributors\n */\nclass CollectionLiteralNode extends ExpressionNode\n{\n    /**\n     * Create a new collection literal node.\n     *\n     * @param array<ExpressionNode> $elements The elements in the collection\n     * @param int                   $line     The line number\n     * @param int                   $column   The column number\n     */\n    public function __construct(\n        private readonly array $elements,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the collection elements.\n     *\n     * @return array<ExpressionNode>\n     */\n    public function getElements(): array\n    {\n        return $this->elements;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitCollectionLiteral($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        if (empty($this->elements)) {\n            return '{}';\n        }\n\n        $elements = array_map(fn (ExpressionNode $e) => $e->toString(), $this->elements);\n\n        return '{' . implode(', ', $elements) . '}';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/ExpressionNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * Base abstract class for all AST nodes in FHIRPath expressions.\n *\n * All expression nodes in the Abstract Syntax Tree extend from this base class.\n * The class supports the Visitor pattern for traversing and processing the AST.\n *\n * @author FHIR Tools Contributors\n */\nabstract class ExpressionNode\n{\n    /**\n     * Create a new expression node.\n     *\n     * @param int $line   The line number where this expression appears\n     * @param int $column The column number where this expression starts\n     */\n    public function __construct(\n        protected int $line,\n        protected int $column\n    ) {\n    }\n\n    /**\n     * Get the line number where this expression appears.\n     */\n    public function getLine(): int\n    {\n        return $this->line;\n    }\n\n    /**\n     * Get the column number where this expression starts.\n     */\n    public function getColumn(): int\n    {\n        return $this->column;\n    }\n\n    /**\n     * Accept a visitor for traversal and processing of the AST.\n     *\n     * This method implements the Visitor pattern, allowing different\n     * operations to be performed on the AST without modifying the node classes.\n     *\n     * @param ExpressionVisitor $visitor The visitor to accept\n     *\n     * @return mixed The result of the visitor's visit method\n     */\n    abstract public function accept(ExpressionVisitor $visitor): mixed;\n\n    /**\n     * Get a string representation of this expression for debugging.\n     *\n     * @return string A human-readable representation of the expression\n     */\n    abstract public function toString(): string;\n\n    /**\n     * Magic method to convert expression to string.\n     *\n     * @return string The expression's string representation\n     */\n    public function __toString(): string\n    {\n        return $this->toString();\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/ExpressionVisitor.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * Visitor interface for traversing and processing the AST.\n *\n * Implementations of this interface can traverse the Abstract Syntax Tree\n * and perform operations on different node types without modifying the nodes.\n *\n * @author FHIR Tools Contributors\n */\ninterface ExpressionVisitor\n{\n    /**\n     * Visit a literal node.\n     *\n     * @param LiteralNode $node The literal node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitLiteral(LiteralNode $node): mixed;\n\n    /**\n     * Visit an identifier node.\n     *\n     * @param IdentifierNode $node The identifier node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitIdentifier(IdentifierNode $node): mixed;\n\n    /**\n     * Visit a binary operator node.\n     *\n     * @param BinaryOperatorNode $node The binary operator node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitBinaryOperator(BinaryOperatorNode $node): mixed;\n\n    /**\n     * Visit a unary operator node.\n     *\n     * @param UnaryOperatorNode $node The unary operator node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitUnaryOperator(UnaryOperatorNode $node): mixed;\n\n    /**\n     * Visit a function call node.\n     *\n     * @param FunctionCallNode $node The function call node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitFunctionCall(FunctionCallNode $node): mixed;\n\n    /**\n     * Visit a member access node.\n     *\n     * @param MemberAccessNode $node The member access node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitMemberAccess(MemberAccessNode $node): mixed;\n\n    /**\n     * Visit an indexer node.\n     *\n     * @param IndexerNode $node The indexer node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitIndexer(IndexerNode $node): mixed;\n\n    /**\n     * Visit a type expression node (is/as).\n     *\n     * @param TypeExpressionNode $node The type expression node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitTypeExpression(TypeExpressionNode $node): mixed;\n\n    /**\n     * Visit an external constant node.\n     *\n     * @param ExternalConstantNode $node The external constant node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitExternalConstant(ExternalConstantNode $node): mixed;\n\n    /**\n     * Visit a collection literal node.\n     *\n     * @param CollectionLiteralNode $node The collection literal node to visit\n     *\n     * @return mixed The result of visiting the node\n     */\n    public function visitCollectionLiteral(CollectionLiteralNode $node): mixed;\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/ExternalConstantNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing an external constant.\n *\n * Represents external constants in FHIRPath that are prefixed with %.\n * For example, `%ucum` or `%context`.\n *\n * @author FHIR Tools Contributors\n */\nclass ExternalConstantNode extends ExpressionNode\n{\n    /**\n     * Create a new external constant node.\n     *\n     * @param string $name   The constant name (without the % prefix)\n     * @param int    $line   The line number\n     * @param int    $column The column number\n     */\n    public function __construct(\n        private readonly string $name,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the constant name.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitExternalConstant($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        return '%' . $this->name;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/FunctionCallNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing a function call.\n *\n * Represents function invocations in FHIRPath expressions with their parameters.\n *\n * @author FHIR Tools Contributors\n */\nclass FunctionCallNode extends ExpressionNode\n{\n    /**\n     * Create a new function call node.\n     *\n     * @param string                $name       The function name\n     * @param array<ExpressionNode> $parameters The function parameters\n     * @param int                   $line       The line number\n     * @param int                   $column     The column number\n     */\n    public function __construct(\n        private readonly string $name,\n        private readonly array $parameters,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the function name.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Get the function parameters.\n     *\n     * @return array<ExpressionNode>\n     */\n    public function getParameters(): array\n    {\n        return $this->parameters;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitFunctionCall($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        $params = array_map(fn (ExpressionNode $p) => $p->toString(), $this->parameters);\n\n        return $this->name . '(' . implode(', ', $params) . ')';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/IdentifierNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing an identifier.\n *\n * Represents simple identifiers in FHIRPath expressions, such as property names\n * and variable names.\n *\n * @author FHIR Tools Contributors\n */\nclass IdentifierNode extends ExpressionNode\n{\n    /**\n     * Create a new identifier node.\n     *\n     * @param string $name   The identifier name\n     * @param int    $line   The line number\n     * @param int    $column The column number\n     */\n    public function __construct(\n        private readonly string $name,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the identifier name.\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitIdentifier($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        return $this->name;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/IndexerNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing an indexer expression.\n *\n * Represents accessing an element by index in a collection using bracket notation.\n * For example, `collection[0]` or `name[index]`.\n *\n * @author FHIR Tools Contributors\n */\nclass IndexerNode extends ExpressionNode\n{\n    /**\n     * Create a new indexer node.\n     *\n     * @param ExpressionNode $collection The collection being indexed\n     * @param ExpressionNode $index      The index expression\n     * @param int            $line       The line number\n     * @param int            $column     The column number\n     */\n    public function __construct(\n        private readonly ExpressionNode $collection,\n        private readonly ExpressionNode $index,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the collection being indexed.\n     */\n    public function getCollection(): ExpressionNode\n    {\n        return $this->collection;\n    }\n\n    /**\n     * Get the index expression.\n     */\n    public function getIndex(): ExpressionNode\n    {\n        return $this->index;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitIndexer($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        return $this->collection->toString() . '[' . $this->index->toString() . ']';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/LiteralNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\TokenType;\n\n/**\n * AST node representing a literal value.\n *\n * Represents literal values in FHIRPath expressions such as strings, numbers,\n * booleans, null, dates, times, and quantities.\n *\n * @author FHIR Tools Contributors\n */\nclass LiteralNode extends ExpressionNode\n{\n    /**\n     * Create a new literal node.\n     *\n     * @param mixed     $value  The literal value\n     * @param TokenType $type   The type of literal\n     * @param int       $line   The line number\n     * @param int       $column The column number\n     */\n    public function __construct(\n        private readonly mixed $value,\n        private readonly TokenType $type,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the literal value.\n     */\n    public function getValue(): mixed\n    {\n        return $this->value;\n    }\n\n    /**\n     * Get the literal type.\n     */\n    public function getType(): TokenType\n    {\n        return $this->type;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitLiteral($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        return match ($this->type) {\n            TokenType::STRING  => \"'\" . addslashes((string) $this->value) . \"'\",\n            TokenType::BOOLEAN => $this->value ? 'true' : 'false',\n            TokenType::NULL    => 'null',\n            default            => (string) $this->value,\n        };\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/MemberAccessNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\n/**\n * AST node representing member access (dot notation).\n *\n * Represents accessing a member or property of an expression in FHIRPath.\n * For example, `Patient.name` where `name` is accessed on `Patient`.\n *\n * @author FHIR Tools Contributors\n */\nclass MemberAccessNode extends ExpressionNode\n{\n    /**\n     * Create a new member access node.\n     *\n     * @param ExpressionNode $object The object/expression to access\n     * @param ExpressionNode $member The member being accessed\n     * @param int            $line   The line number\n     * @param int            $column The column number\n     */\n    public function __construct(\n        private readonly ExpressionNode $object,\n        private readonly ExpressionNode $member,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the object being accessed.\n     */\n    public function getObject(): ExpressionNode\n    {\n        return $this->object;\n    }\n\n    /**\n     * Get the member being accessed.\n     */\n    public function getMember(): ExpressionNode\n    {\n        return $this->member;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitMemberAccess($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        return $this->object->toString() . '.' . $this->member->toString();\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/TypeExpressionNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\TokenType;\n\n/**\n * AST node representing a type expression (is/as).\n *\n * Represents type checking and type casting operations in FHIRPath.\n * For example, `value is Integer` or `value as Patient`.\n *\n * @author FHIR Tools Contributors\n */\nclass TypeExpressionNode extends ExpressionNode\n{\n    /**\n     * Create a new type expression node.\n     *\n     * @param ExpressionNode $expression The expression to check/cast\n     * @param TokenType      $operator   The operator (IS or AS)\n     * @param string         $typeName   The type name to check/cast to\n     * @param int            $line       The line number\n     * @param int            $column     The column number\n     */\n    public function __construct(\n        private readonly ExpressionNode $expression,\n        private readonly TokenType $operator,\n        private readonly string $typeName,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the expression being checked/cast.\n     */\n    public function getExpression(): ExpressionNode\n    {\n        return $this->expression;\n    }\n\n    /**\n     * Get the operator (IS or AS).\n     */\n    public function getOperator(): TokenType\n    {\n        return $this->operator;\n    }\n\n    /**\n     * Get the type name.\n     */\n    public function getTypeName(): string\n    {\n        return $this->typeName;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitTypeExpression($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        $operator = $this->operator === TokenType::IS ? ' is ' : ' as ';\n\n        return '(' . $this->expression->toString() . $operator . $this->typeName . ')';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Expression/UnaryOperatorNode.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\TokenType;\n\n/**\n * AST node representing a unary operator expression.\n *\n * Represents unary operations in FHIRPath such as negation (-) or positive (+).\n *\n * @author FHIR Tools Contributors\n */\nclass UnaryOperatorNode extends ExpressionNode\n{\n    /**\n     * Create a new unary operator node.\n     *\n     * @param TokenType      $operator The operator (PLUS or MINUS)\n     * @param ExpressionNode $operand  The operand\n     * @param int            $line     The line number\n     * @param int            $column   The column number\n     */\n    public function __construct(\n        private readonly TokenType $operator,\n        private readonly ExpressionNode $operand,\n        int $line,\n        int $column\n    ) {\n        parent::__construct($line, $column);\n    }\n\n    /**\n     * Get the operator.\n     */\n    public function getOperator(): TokenType\n    {\n        return $this->operator;\n    }\n\n    /**\n     * Get the operand.\n     */\n    public function getOperand(): ExpressionNode\n    {\n        return $this->operand;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function accept(ExpressionVisitor $visitor): mixed\n    {\n        return $visitor->visitUnaryOperator($this);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function toString(): string\n    {\n        $operatorStr = $this->operator === TokenType::MINUS ? '-' : '+';\n\n        return '(' . $operatorStr . $this->operand->toString() . ')';\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AbsFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath abs() function.\n *\n * Returns the absolute value of the input number.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class AbsFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('abs');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $value = $input->first();\n        if (!is_numeric($value)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'number');\n        }\n\n        // Ensure we have a numeric value for abs()\n        $numericValue = is_string($value) ? (float) $value : $value;\n\n        return Collection::single(abs($numericValue));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AbstractFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Abstract base class for FHIRPath functions.\n *\n * Provides common functionality for parameter validation and utilities.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nabstract class AbstractFunction implements FunctionInterface\n{\n    /**\n     * @param string $name The function name\n     */\n    public function __construct(\n        private readonly string $name\n    ) {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    /**\n     * Validate the number of parameters.\n     *\n     * @param array<int, mixed> $parameters The parameters to validate\n     * @param int               $expected   The expected number of parameters\n     * @param int|null          $max        The maximum number of parameters (if different from expected)\n     *\n     * @throws EvaluationException If parameter count is invalid\n     */\n    protected function validateParameterCount(array $parameters, int $expected, ?int $max = null): void\n    {\n        $count = count($parameters);\n        $max   = $max ?? $expected;\n\n        if ($count < $expected || $count > $max) {\n            if ($expected === $max) {\n                throw new EvaluationException(sprintf('Function %s() expects exactly %d parameter(s), %d given', $this->name, $expected, $count), 0, 0);\n            }\n\n            throw new EvaluationException(sprintf('Function %s() expects %d-%d parameter(s), %d given', $this->name, $expected, $max, $count), 0, 0);\n        }\n    }\n\n    /**\n     * Validate minimum parameter count.\n     *\n     * @param array<int, mixed> $parameters The parameters to validate\n     * @param int               $min        The minimum number of parameters\n     *\n     * @throws EvaluationException If parameter count is too low\n     */\n    protected function validateMinParameters(array $parameters, int $min): void\n    {\n        $count = count($parameters);\n\n        if ($count < $min) {\n            throw new EvaluationException(sprintf('Function %s() expects at least %d parameter(s), %d given', $this->name, $min, $count), 0, 0);\n        }\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AllFalseFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * Returns true if all items in the collection are false.\n * Empty collection returns true.\n *\n * @author FHIR Tools Contributors\n */\nclass AllFalseFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('allFalse');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::single(true);\n        }\n\n        foreach ($input as $item) {\n            if ($item !== false) {\n                return Collection::single(false);\n            }\n        }\n\n        return Collection::single(true);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AllFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\n\n/**\n * all(criteria) function - Returns true if all items match the criteria\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class AllFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('all');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        /** @var ExpressionNode $criteriaExpr */\n        $criteriaExpr = $parameters[0];\n\n        // Empty collection returns true (vacuous truth)\n        if ($input->isEmpty()) {\n            return Collection::single(true);\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not set in context', 0, 0);\n        }\n\n        foreach ($input as $item) {\n            $itemContext = $context->withCurrentNode($item);\n            $result      = $criteriaExpr->accept($evaluator);\n\n            // If any item doesn't match (false or empty), return false\n            if ($result->isEmpty() || $result->first() !== true) {\n                return Collection::single(false);\n            }\n        }\n\n        return Collection::single(true);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AllTrueFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * Returns true if all items in the collection are true.\n * Empty collection returns true.\n *\n * @author FHIR Tools Contributors\n */\nclass AllTrueFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('allTrue');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::single(true);\n        }\n\n        foreach ($input as $item) {\n            if ($item !== true) {\n                return Collection::single(false);\n            }\n        }\n\n        return Collection::single(true);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AnyFalseFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * Returns true if any item in the collection is false.\n * Empty collection returns false.\n *\n * @author FHIR Tools Contributors\n */\nclass AnyFalseFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('anyFalse');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        foreach ($input as $item) {\n            if ($item === false) {\n                return Collection::single(true);\n            }\n        }\n\n        return Collection::single(false);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AnyTrueFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * Returns true if any item in the collection is true.\n * Empty collection returns false.\n *\n * @author FHIR Tools Contributors\n */\nclass AnyTrueFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('anyTrue');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        foreach ($input as $item) {\n            if ($item === true) {\n                return Collection::single(true);\n            }\n        }\n\n        return Collection::single(false);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/AvgFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath avg() function.\n *\n * Returns the average (arithmetic mean) of the numeric values in the collection.\n * All items must be numeric.\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass AvgFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('avg');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $sum   = 0;\n        $count = 0;\n\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('avg', 'numeric values', gettype($item));\n            }\n\n            $sum += $item;\n            ++$count;\n        }\n\n        return Collection::single($sum / $count);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/CeilingFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath ceiling() function.\n *\n * Returns the smallest integer greater than or equal to the input number.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class CeilingFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('ceiling');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $value = $input->first();\n        if (!is_numeric($value)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'number');\n        }\n\n        return Collection::single((int) ceil((float) $value));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/CombineFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath combine() function.\n *\n * Combines two collections, keeping all duplicates (unlike union).\n * For input collection + other: combine(other), returns all items from both\n * For empty collection: returns other collection\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass CombineFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('combine');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1, 1);\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $otherResult = $evaluator->evaluate($parameters[0], $context);\n\n        // Combine keeps all items including duplicates\n        $items = [];\n\n        foreach ($input as $item) {\n            $items[] = $item;\n        }\n\n        foreach ($otherResult as $item) {\n            $items[] = $item;\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ContainsStringFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Returns true if string contains the given substring.\n *\n * @author FHIR Tools Contributors\n */\nclass ContainsStringFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('contains');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            return Collection::single(false);\n        }\n\n        /** @var ExpressionNode $substringExpr */\n        $substringExpr = $parameters[0];\n        $evaluator     = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n        $substringResult = $evaluator->evaluate($substringExpr, $context);\n\n        if ($substringResult->isEmpty()) {\n            return Collection::single(false);\n        }\n\n        $substring = $substringResult->first();\n        if (!is_string($substring)) {\n            return Collection::single(false);\n        }\n\n        return Collection::single(str_contains($string, $substring));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/CountFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * count() function - Returns the number of items in the collection\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class CountFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('count');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        return Collection::single($input->count());\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/DistinctFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * Returns collection with duplicate values removed.\n *\n * @author FHIR Tools Contributors\n */\nclass DistinctFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('distinct');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $distinct = [];\n        $seen     = [];\n\n        foreach ($input as $item) {\n            $key = $this->getItemKey($item);\n            if (!isset($seen[$key])) {\n                $seen[$key] = true;\n                $distinct[] = $item;\n            }\n        }\n\n        return Collection::from($distinct);\n    }\n\n    private function getItemKey(mixed $item): string\n    {\n        if (is_scalar($item) || $item === null) {\n            return serialize($item);\n        }\n\n        if (is_object($item)) {\n            return spl_object_hash($item);\n        }\n\n        return serialize($item);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/EmptyFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * empty() function - Returns true if the input collection is empty\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class EmptyFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('empty');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        return Collection::single($input->isEmpty());\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/EndsWithFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Returns true if string ends with the given suffix.\n *\n * @author FHIR Tools Contributors\n */\nclass EndsWithFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('endsWith');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            return Collection::single(false);\n        }\n\n        /** @var ExpressionNode $suffixExpr */\n        $suffixExpr = $parameters[0];\n        $evaluator  = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n        $suffixResult = $evaluator->evaluate($suffixExpr, $context);\n\n        if ($suffixResult->isEmpty()) {\n            return Collection::single(false);\n        }\n\n        $suffix = $suffixResult->first();\n        if (!is_string($suffix)) {\n            return Collection::single(false);\n        }\n\n        return Collection::single(str_ends_with($string, $suffix));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ExcludeFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Returns items in this collection that are not in the other collection.\n *\n * @author FHIR Tools Contributors\n */\nclass ExcludeFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('exclude');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        /** @var ExpressionNode $otherExpr */\n        $otherExpr = $parameters[0];\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n        $otherResult = $evaluator->evaluate($otherExpr, $context);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        if ($otherResult->isEmpty()) {\n            return $input;\n        }\n\n        $otherItems = [];\n        foreach ($otherResult as $item) {\n            $otherItems[] = $item;\n        }\n\n        $result = [];\n        foreach ($input as $item) {\n            if (!in_array($item, $otherItems, true)) {\n                $result[] = $item;\n            }\n        }\n\n        return Collection::from($result);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ExistsFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\n\n/**\n * exists([criteria]) function - Returns true if collection has any items (optionally matching criteria)\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class ExistsFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('exists');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 1);\n\n        // No criteria - check if any items exist\n        if (count($parameters) === 0) {\n            return Collection::single(!$input->isEmpty());\n        }\n\n        // With criteria - check if any item matches\n        /** @var ExpressionNode $criteriaExpr */\n        $criteriaExpr = $parameters[0];\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not set in context', 0, 0);\n        }\n\n        foreach ($input as $item) {\n            $itemContext = $context->withCurrentNode($item);\n            $result      = $criteriaExpr->accept($evaluator);\n\n            if (!$result->isEmpty() && $result->first() === true) {\n                return Collection::single(true);\n            }\n        }\n\n        return Collection::single(false);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ExpFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath exp() function.\n *\n * Returns e raised to the power of the input value (e^x).\n * For single item: exp(), returns e^x\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass ExpFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('exp');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('exp', 'numeric value', gettype($item));\n            }\n\n            $items[] = exp((float) $item);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/FirstFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * first() function - Returns the first item in the collection\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class FirstFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('first');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        return Collection::single($input->first());\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/FloorFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath floor() function.\n *\n * Returns the largest integer less than or equal to the input number.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class FloorFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('floor');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $value = $input->first();\n        if (!is_numeric($value)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'number');\n        }\n\n        return Collection::single((int) floor((float) $value));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/FunctionInterface.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Interface for FHIRPath functions.\n *\n * All FHIRPath functions must implement this interface to be registered\n * and executed by the evaluator.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\ninterface FunctionInterface\n{\n    /**\n     * Get the function name.\n     *\n     * @return string The function name (e.g., 'where', 'select', 'first')\n     */\n    public function getName(): string;\n\n    /**\n     * Execute the function with given input collection and parameters.\n     *\n     * @param Collection        $input      The input collection to operate on\n     * @param array<int, mixed> $parameters Function parameters (expressions or values)\n     * @param EvaluationContext $context    The evaluation context\n     *\n     * @return Collection The result collection\n     *\n     * @throws EvaluationException\n     */\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection;\n}\n",
        "/fhir/Component/FHIRPath/src/Function/FunctionRegistry.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Registry for FHIRPath functions.\n *\n * Manages registration and lookup of all available FHIRPath functions.\n * Uses singleton pattern to ensure single registry instance.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class FunctionRegistry\n{\n    private static ?self $instance = null;\n\n    /**\n     * @var array<string, FunctionInterface>\n     */\n    private array $functions = [];\n\n    private function __construct()\n    {\n        // Private constructor for singleton\n        $this->registerBuiltInFunctions();\n    }\n\n    /**\n     * Register all built-in FHIRPath functions.\n     */\n    private function registerBuiltInFunctions(): void\n    {\n        // Existence functions\n        $this->registerSafe(new EmptyFunction());\n        $this->registerSafe(new ExistsFunction());\n        $this->registerSafe(new AllFunction());\n        $this->registerSafe(new CountFunction());\n        $this->registerSafe(new AllTrueFunction());\n        $this->registerSafe(new AnyTrueFunction());\n        $this->registerSafe(new AllFalseFunction());\n        $this->registerSafe(new AnyFalseFunction());\n\n        // Filtering functions\n        $this->registerSafe(new WhereFunction());\n        $this->registerSafe(new SelectFunction());\n        $this->registerSafe(new FirstFunction());\n        $this->registerSafe(new LastFunction());\n        $this->registerSafe(new TailFunction());\n        $this->registerSafe(new TakeFunction());\n        $this->registerSafe(new SkipFunction());\n        $this->registerSafe(new SingleFunction());\n        $this->registerSafe(new DistinctFunction());\n\n        // Subsetting functions\n        $this->registerSafe(new UnionFunction());\n        $this->registerSafe(new IntersectFunction());\n        $this->registerSafe(new ExcludeFunction());\n\n        // String functions\n        $this->registerSafe(new SubstringFunction());\n        $this->registerSafe(new LengthFunction());\n        $this->registerSafe(new StartsWithFunction());\n        $this->registerSafe(new EndsWithFunction());\n        $this->registerSafe(new ContainsStringFunction());\n        $this->registerSafe(new IndexOfFunction());\n        $this->registerSafe(new UpperFunction());\n        $this->registerSafe(new LowerFunction());\n        $this->registerSafe(new ReplaceFunction());\n        $this->registerSafe(new MatchesFunction());\n        $this->registerSafe(new TrimFunction());\n        $this->registerSafe(new SplitFunction());\n\n        // Math functions\n        $this->registerSafe(new SumFunction());\n        $this->registerSafe(new AbsFunction());\n        $this->registerSafe(new CeilingFunction());\n        $this->registerSafe(new FloorFunction());\n        $this->registerSafe(new TruncateFunction());\n        $this->registerSafe(new RoundFunction());\n        $this->registerSafe(new ExpFunction());\n        $this->registerSafe(new LnFunction());\n        $this->registerSafe(new LogFunction());\n        $this->registerSafe(new PowerFunction());\n        $this->registerSafe(new SqrtFunction());\n        $this->registerSafe(new MinFunction());\n        $this->registerSafe(new MaxFunction());\n        $this->registerSafe(new AvgFunction());\n\n        // Date/Time functions\n        $this->registerSafe(new NowFunction());\n        $this->registerSafe(new TimeOfDayFunction());\n        $this->registerSafe(new TodayFunction());\n        $this->registerSafe(new ToMillisecondsFunction());\n        $this->registerSafe(new ToSecondsFunction());\n\n        // Type functions\n        $this->registerSafe(new OfTypeFunction());\n        $this->registerSafe(new HasValueFunction());\n\n        // Combining functions\n        $this->registerSafe(new CombineFunction());\n        $this->registerSafe(new IifFunction());\n    }\n\n    /**\n     * Register a function without throwing if it already exists.\n     */\n    private function registerSafe(FunctionInterface $function): void\n    {\n        $name = $function->getName();\n        if (!isset($this->functions[$name])) {\n            $this->functions[$name] = $function;\n        }\n    }\n\n    /**\n     * Get the singleton registry instance.\n     *\n     * @return self\n     */\n    public static function getInstance(): self\n    {\n        if (self::$instance === null) {\n            self::$instance = new self();\n        }\n\n        return self::$instance;\n    }\n\n    /**\n     * Register a function.\n     *\n     * @param FunctionInterface $function The function to register\n     *\n     * @throws EvaluationException If function with same name already registered\n     */\n    public function register(FunctionInterface $function): void\n    {\n        $name = $function->getName();\n\n        if (isset($this->functions[$name])) {\n            throw new EvaluationException(sprintf('Function \"%s\" is already registered', $name), 0, 0);\n        }\n\n        $this->functions[$name] = $function;\n    }\n\n    /**\n     * Get a function by name.\n     *\n     * @param string $name The function name\n     *\n     * @return FunctionInterface The function\n     *\n     * @throws EvaluationException If function not found\n     */\n    public function get(string $name): FunctionInterface\n    {\n        if (!isset($this->functions[$name])) {\n            throw new EvaluationException(sprintf('Unknown function \"%s\"', $name), 0, 0);\n        }\n\n        return $this->functions[$name];\n    }\n\n    /**\n     * Check if a function is registered.\n     *\n     * @param string $name The function name\n     *\n     * @return bool\n     */\n    public function has(string $name): bool\n    {\n        return isset($this->functions[$name]);\n    }\n\n    /**\n     * Get all registered function names.\n     *\n     * @return array<int, string>\n     */\n    public function getFunctionNames(): array\n    {\n        return array_keys($this->functions);\n    }\n\n    /**\n     * Clear all registered functions (for testing).\n     *\n     * @internal\n     */\n    public function clear(): void\n    {\n        $this->functions = [];\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/HasValueFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * FHIRPath hasValue() function.\n *\n * Returns true if the input has a value (not just extensions).\n * For FHIR primitives, checks if the primitive value exists (not just extension).\n * For other types, returns true if not empty.\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass HasValueFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('hasValue');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            // Check if object has a value property (FHIR primitive pattern)\n            if (is_object($item)) {\n                $hasValue = property_exists($item, 'value') && $item->value !== null;\n                $items[]  = $hasValue;\n            } else {\n                // For non-objects, any non-null value is considered having value\n                $items[] = $item !== null;\n            }\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/IifFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath iif() function.\n *\n * Conditional expression: if condition is true, returns ifTrue, else returns ifFalse.\n * For any input: iif(condition, ifTrue, ifFalse)\n * Condition must evaluate to a single boolean value.\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass IifFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('iif');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 3, 3);\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        // Evaluate condition\n        $conditionResult = $evaluator->evaluate($parameters[0], $context);\n\n        // If condition is empty or not boolean, return empty\n        if ($conditionResult->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $condition = $conditionResult->first();\n\n        // If condition is true, evaluate and return ifTrue branch\n        if ($condition === true) {\n            return $evaluator->evaluate($parameters[1], $context);\n        }\n\n        // Otherwise, evaluate and return ifFalse branch\n        return $evaluator->evaluate($parameters[2], $context);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/IndexOfFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath indexOf() function.\n *\n * Returns the zero-based index of the first occurrence of the substring in the input string,\n * or -1 if the substring is not found.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class IndexOfFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('indexOf');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $substring = $evaluator->evaluate($parameters[0], $context)->first();\n        if (!is_string($substring)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'substring', 'string');\n        }\n\n        $position = strpos($string, $substring);\n\n        return Collection::single($position !== false ? $position : -1);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/IntersectFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * intersect(other) function - Returns the intersection of two collections\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class IntersectFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('intersect');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        $otherCollection = $parameters[0];\n        if (!$otherCollection instanceof Collection) {\n            return Collection::empty();\n        }\n\n        return $input->intersect($otherCollection);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/LastFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * last() function - Returns the last item in the collection\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class LastFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('last');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        return Collection::single($input->last());\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/LengthFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * length() function - Returns the length of a string\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class LengthFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('length');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $str = $input->first();\n        if (!is_string($str)) {\n            throw EvaluationException::invalidFunctionParameter('length', 'input', 'string');\n        }\n\n        return Collection::single(strlen($str));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/LnFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath ln() function.\n *\n * Returns the natural logarithm (base e) of the input value.\n * For single item: ln(), returns natural logarithm\n * For empty collection: returns empty\n * Throws exception if value <= 0\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass LnFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('ln');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('ln', 'numeric value', gettype($item));\n            }\n\n            $value = (float) $item;\n            if ($value <= 0) {\n                throw EvaluationException::invalidFunctionParameter('ln', 'positive number', 'number <= 0');\n            }\n\n            $items[] = log($value);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/LogFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath log() function.\n *\n * Returns the logarithm base 10 of the input value.\n * For single item: log(), returns base 10 logarithm\n * For empty collection: returns empty\n * Throws exception if value <= 0\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass LogFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('log');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('log', 'numeric value', gettype($item));\n            }\n\n            $value = (float) $item;\n            if ($value <= 0) {\n                throw EvaluationException::invalidFunctionParameter('log', 'positive number', 'number <= 0');\n            }\n\n            $items[] = log10($value);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/LowerFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath lower() function.\n *\n * Returns the input string converted to lowercase.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class LowerFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('lower');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        return Collection::single(strtolower($string));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/MatchesFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath matches() function.\n *\n * Returns true if the input string matches the given regular expression pattern.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class MatchesFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('matches');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $pattern = $evaluator->evaluate($parameters[0], $context)->first();\n        if (!is_string($pattern)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'pattern', 'string');\n        }\n\n        // Add delimiters if not present\n        if (!str_starts_with($pattern, '/')) {\n            $pattern = '/' . $pattern . '/';\n        }\n\n        $result = @preg_match($pattern, $string);\n\n        if ($result === false) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'pattern', 'valid regular expression');\n        }\n\n        return Collection::single($result === 1);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/MaxFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath max() function.\n *\n * Returns the maximum value in the collection.\n * All items must be numeric.\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass MaxFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('max');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $max = null;\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('max', 'numeric values', gettype($item));\n            }\n\n            if ($max === null || $item > $max) {\n                $max = $item;\n            }\n        }\n\n        return Collection::single($max);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/MinFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath min() function.\n *\n * Returns the minimum value in the collection.\n * All items must be numeric.\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass MinFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('min');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $min = null;\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('min', 'numeric values', gettype($item));\n            }\n\n            if ($min === null || $item < $min) {\n                $min = $item;\n            }\n        }\n\n        return Collection::single($min);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/NowFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse DateTime;\n\n/**\n * FHIRPath now() function.\n *\n * Returns the current date and time as a DateTime.\n * Takes no parameters.\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass NowFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('now');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        return Collection::single(new \\DateTime());\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/OfTypeFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath ofType() function.\n *\n * Filters the collection to only items of the specified FHIR type.\n * For collection: ofType(typeName), returns items matching the type\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass OfTypeFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('ofType');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $typeResult = $evaluator->evaluate($parameters[0], $context);\n        if ($typeResult->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $typeName = $typeResult->first();\n        if (!is_string($typeName)) {\n            throw EvaluationException::invalidFunctionParameter('ofType', 'typeName', 'string');\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (is_object($item)) {\n                $className = get_class($item);\n                $shortName = substr($className, strrpos($className, '\\\\') + 1);\n\n                if ($shortName === $typeName || $className === $typeName) {\n                    $items[] = $item;\n                }\n            }\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/PowerFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath power() function.\n *\n * Raises the input value to the specified power (x^exponent).\n * For single item: power(exponent), returns x^exponent\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass PowerFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('power');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $exponentResult = $evaluator->evaluate($parameters[0], $context);\n        if ($exponentResult->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $exponent = $exponentResult->first();\n        if (!is_numeric($exponent)) {\n            throw EvaluationException::invalidFunctionParameter('power', 'exponent', 'number');\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('power', 'input', 'number');\n            }\n\n            $items[] = pow((float) $item, (float) $exponent);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ReplaceFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath replace() function.\n *\n * Returns the input string with all occurrences of the search string replaced\n * with the replacement string.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class ReplaceFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('replace');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 2);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $search = $evaluator->evaluate($parameters[0], $context)->first();\n        if (!is_string($search)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'search', 'string');\n        }\n\n        $replace = $evaluator->evaluate($parameters[1], $context)->first();\n        if (!is_string($replace)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'replacement', 'string');\n        }\n\n        return Collection::single(str_replace($search, $replace, $string));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/RoundFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath round() function.\n *\n * Rounds a number to the nearest integer or to N decimal places if precision specified.\n * For single item: round([precision]), returns rounded number\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass RoundFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('round');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $precision = 0;\n        if (!empty($parameters)) {\n            $evaluator = $context->getEvaluator();\n            if ($evaluator === null) {\n                throw new EvaluationException('Evaluator not available in context');\n            }\n\n            $precisionResult = $evaluator->evaluate($parameters[0], $context);\n            if (!$precisionResult->isEmpty()) {\n                $precisionValue = $precisionResult->first();\n                if (!is_numeric($precisionValue)) {\n                    throw EvaluationException::invalidFunctionParameter('round', 'precision', 'number');\n                }\n                $precision = (int) $precisionValue;\n            }\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('round', 'input', 'number');\n            }\n\n            $items[] = round((float) $item, $precision);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SelectFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Transforms each item in collection using projection expression.\n *\n * @author FHIR Tools Contributors\n */\nclass SelectFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('select');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        /** @var ExpressionNode $projection */\n        $projection = $parameters[0];\n        $evaluator  = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $results = [];\n\n        foreach ($input as $index => $item) {\n            $itemContext = $context\n                ->withCurrentNode($item)\n                ->withIterationVariables($item, $index, $input->count());\n\n            $result = $evaluator->evaluate($projection, $itemContext);\n            foreach ($result as $value) {\n                $results[] = $value;\n            }\n        }\n\n        return Collection::from($results);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SingleFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Returns the single item in collection. Throws if not exactly one item.\n *\n * @author FHIR Tools Contributors\n */\nclass SingleFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('single');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            throw EvaluationException::invalidFunctionParameter('single', 'collection', 'non-empty collection');\n        }\n\n        if ($input->count() > 1) {\n            throw EvaluationException::invalidFunctionParameter('single', 'collection', 'single item collection');\n        }\n\n        return $input;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SkipFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * skip(num) function - Returns all items except the first num\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class SkipFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('skip');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        $numCollection = $parameters[0];\n        if (!($numCollection instanceof Collection) || $numCollection->isEmpty()) {\n            throw EvaluationException::invalidFunctionParameter('skip', 'num', 'non-empty integer collection');\n        }\n\n        $num = $numCollection->first();\n        if (!is_int($num) || $num < 0) {\n            throw EvaluationException::invalidFunctionParameter('skip', 'num', 'non-negative integer');\n        }\n\n        if ($num === 0) {\n            return $input;\n        }\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        $count = 0;\n        foreach ($input as $item) {\n            if ($count < $num) {\n                ++$count;\n                continue;\n            }\n            $items[] = $item;\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SplitFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath split() function.\n *\n * Splits the input string into a collection of strings using the given delimiter.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class SplitFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('split');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n\n        $delimiter = $evaluator->evaluate($parameters[0], $context)->first();\n        if (!is_string($delimiter)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'delimiter', 'string');\n        }\n\n        if ($delimiter === '') {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'delimiter', 'non-empty string');\n        }\n\n        $parts = explode($delimiter, $string);\n\n        return Collection::from($parts);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SqrtFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath sqrt() function.\n *\n * Returns the square root of the input value.\n * For single item: sqrt(), returns square root\n * For empty collection: returns empty\n * Throws exception if value < 0\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass SqrtFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('sqrt');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('sqrt', 'numeric value', gettype($item));\n            }\n\n            $value = (float) $item;\n            if ($value < 0) {\n                throw EvaluationException::invalidFunctionParameter('sqrt', 'non-negative number', 'negative number');\n            }\n\n            $items[] = sqrt($value);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/StartsWithFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * Returns true if string starts with the given prefix.\n *\n * @author FHIR Tools Contributors\n */\nclass StartsWithFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('startsWith');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            return Collection::single(false);\n        }\n\n        /** @var ExpressionNode $prefixExpr */\n        $prefixExpr = $parameters[0];\n        $evaluator  = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not available in context');\n        }\n        $prefixResult = $evaluator->evaluate($prefixExpr, $context);\n\n        if ($prefixResult->isEmpty()) {\n            return Collection::single(false);\n        }\n\n        $prefix = $prefixResult->first();\n        if (!is_string($prefix)) {\n            return Collection::single(false);\n        }\n\n        return Collection::single(str_starts_with($string, $prefix));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SubstringFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * substring(start, [length]) function - Extracts a substring\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class SubstringFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('substring');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1, 2);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $str = $input->first();\n        if (!is_string($str)) {\n            throw EvaluationException::invalidFunctionParameter('substring', 'input', 'string');\n        }\n\n        $startCollection = $parameters[0];\n        if (!($startCollection instanceof Collection) || $startCollection->isEmpty()) {\n            throw EvaluationException::invalidFunctionParameter('substring', 'start', 'non-empty integer collection');\n        }\n\n        $start = $startCollection->first();\n        if (!is_int($start) || $start < 0) {\n            throw EvaluationException::invalidFunctionParameter('substring', 'start', 'non-negative integer');\n        }\n\n        // Optional length parameter\n        $length = null;\n        if (count($parameters) === 2) {\n            $lengthCollection = $parameters[1];\n            if (!($lengthCollection instanceof Collection) || $lengthCollection->isEmpty()) {\n                throw EvaluationException::invalidFunctionParameter('substring', 'length', 'non-empty integer collection');\n            }\n\n            $length = $lengthCollection->first();\n            if (!is_int($length) || $length < 0) {\n                throw EvaluationException::invalidFunctionParameter('substring', 'length', 'non-negative integer');\n            }\n        }\n\n        $result = $length !== null ? substr($str, $start, $length) : substr($str, $start);\n\n        return Collection::single($result);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/SumFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * sum() function - Returns the sum of all numeric values in the collection\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class SumFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('sum');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $sum = 0;\n        foreach ($input as $item) {\n            if (is_int($item) || is_float($item)) {\n                $sum += $item;\n            }\n        }\n\n        return Collection::single($sum);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TailFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * tail() function - Returns all items except the first\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class TailFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('tail');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        $first = true;\n        foreach ($input as $item) {\n            if ($first) {\n                $first = false;\n                continue;\n            }\n            $items[] = $item;\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TakeFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * take(num) function - Returns the first num items from the collection\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class TakeFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('take');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        $numCollection = $parameters[0];\n        if (!($numCollection instanceof Collection) || $numCollection->isEmpty()) {\n            throw EvaluationException::invalidFunctionParameter('take', 'num', 'non-empty integer collection');\n        }\n\n        $num = $numCollection->first();\n        if (!is_int($num) || $num < 0) {\n            throw EvaluationException::invalidFunctionParameter('take', 'num', 'non-negative integer');\n        }\n\n        if ($num === 0 || $input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        $count = 0;\n        foreach ($input as $item) {\n            if ($count >= $num) {\n                break;\n            }\n            $items[] = $item;\n            ++$count;\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TimeOfDayFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * FHIRPath timeOfDay() function.\n *\n * Returns the current time of day (time only, no date).\n * Takes no parameters.\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass TimeOfDayFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('timeOfDay');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        // Return time portion as string in format HH:mm:ss\n        $now = new \\DateTime();\n\n        return Collection::single($now->format('H:i:s'));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ToMillisecondsFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse DateTime;\n\n/**\n * FHIRPath toMilliseconds() function.\n *\n * Converts a DateTime to milliseconds since Unix epoch (1970-01-01 00:00:00 UTC).\n * For single DateTime item: returns milliseconds as integer\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass ToMillisecondsFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('toMilliseconds');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!$item instanceof \\DateTime) {\n                throw EvaluationException::invalidFunctionParameter('toMilliseconds', 'DateTime', gettype($item));\n            }\n\n            // Get milliseconds since epoch\n            $items[] = (int) ($item->getTimestamp() * 1000);\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/ToSecondsFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse DateTime;\n\n/**\n * FHIRPath toSeconds() function.\n *\n * Converts a DateTime to seconds since Unix epoch (1970-01-01 00:00:00 UTC).\n * For single DateTime item: returns seconds as integer\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass ToSecondsFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('toSeconds');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!$item instanceof \\DateTime) {\n                throw EvaluationException::invalidFunctionParameter('toSeconds', 'DateTime', gettype($item));\n            }\n\n            $items[] = $item->getTimestamp();\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TodayFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * FHIRPath today() function.\n *\n * Returns the current date (date only, no time).\n * Takes no parameters.\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass TodayFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('today');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        // Return date portion as string in format YYYY-MM-DD\n        $now = new \\DateTime();\n\n        return Collection::single($now->format('Y-m-d'));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TrimFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath trim() function.\n *\n * Returns the input string with leading and trailing whitespace removed.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class TrimFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('trim');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        return Collection::single(trim($string));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/TruncateFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath truncate() function.\n *\n * Returns the integer portion of a number (removes decimal part).\n * For single item: truncate(), returns integer part\n * For empty collection: returns empty\n *\n * @author Ardenexal <info@ardenexal.com>\n */\nclass TruncateFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('truncate');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $items = [];\n        foreach ($input as $item) {\n            if (!is_numeric($item)) {\n                throw EvaluationException::invalidFunctionParameter('truncate', 'numeric value', gettype($item));\n            }\n\n            $items[] = (int) $item;\n        }\n\n        return Collection::from($items);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/UnionFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\n\n/**\n * union(other) function - Returns the union of two collections (no duplicates)\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class UnionFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('union');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        $otherCollection = $parameters[0];\n        if (!$otherCollection instanceof Collection) {\n            return $input;\n        }\n\n        return $input->union($otherCollection);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/UpperFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\n\n/**\n * FHIRPath upper() function.\n *\n * Returns the input string converted to uppercase.\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class UpperFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('upper');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 0);\n\n        if ($input->isEmpty()) {\n            return Collection::empty();\n        }\n\n        $string = $input->first();\n        if (!is_string($string)) {\n            throw EvaluationException::invalidFunctionParameter($this->getName(), 'input', 'string');\n        }\n\n        return Collection::single(strtoupper($string));\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Function/WhereFunction.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Function;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\n\n/**\n * where(criteria) function - Filters the collection by criteria expression\n *\n * @author Ardenexal <https://github.com/Ardenexal>\n */\nfinal class WhereFunction extends AbstractFunction\n{\n    public function __construct()\n    {\n        parent::__construct('where');\n    }\n\n    public function execute(Collection $input, array $parameters, EvaluationContext $context): Collection\n    {\n        $this->validateParameterCount($parameters, 1);\n\n        /** @var ExpressionNode $criteriaExpr */\n        $criteriaExpr = $parameters[0];\n\n        $evaluator = $context->getEvaluator();\n        if ($evaluator === null) {\n            throw new EvaluationException('Evaluator not set in context', 0, 0);\n        }\n\n        return $input->filter(function($item) use ($criteriaExpr, $context, $evaluator) {\n            $itemContext = $context->withCurrentNode($item);\n            $result      = $criteriaExpr->accept($evaluator);\n\n            // Item matches if result is true\n            return !$result->isEmpty() && $result->first() === true;\n        });\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Parser/FHIRPathLexer.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\TokenException;\n\n/**\n * Lexical analyzer for FHIRPath expressions.\n *\n * The lexer tokenizes a FHIRPath expression string into a sequence of tokens\n * that can be processed by the parser. It handles:\n * - Keywords and identifiers\n * - Operators (single and multi-character)\n * - Literals (strings, numbers, booleans, dates, quantities)\n * - Delimiters\n * - Position tracking for error reporting\n *\n * @author FHIR Tools Contributors\n */\nclass FHIRPathLexer\n{\n    private string $input = '';\n\n    private int $position = 0;\n\n    private int $line = 1;\n\n    private int $column = 1;\n\n    /** @var array<Token> */\n    private array $tokens = [];\n\n    /** @var array<string, TokenType> Keyword to token type mapping */\n    private const KEYWORDS = [\n        'and'      => TokenType::AND,\n        'or'       => TokenType::OR,\n        'xor'      => TokenType::XOR,\n        'implies'  => TokenType::IMPLIES,\n        'as'       => TokenType::AS,\n        'is'       => TokenType::IS,\n        'in'       => TokenType::IN,\n        'contains' => TokenType::CONTAINS,\n        'div'      => TokenType::DIV,\n        'mod'      => TokenType::MOD,\n        'true'     => TokenType::BOOLEAN,\n        'false'    => TokenType::BOOLEAN,\n    ];\n\n    /**\n     * Tokenize a FHIRPath expression into a list of tokens.\n     *\n     * @param string $expression The FHIRPath expression to tokenize\n     *\n     * @return array<Token> Array of tokens including EOF token at the end\n     *\n     * @throws TokenException If lexical analysis fails\n     */\n    public function tokenize(string $expression): array\n    {\n        $this->input    = $expression;\n        $this->position = 0;\n        $this->line     = 1;\n        $this->column   = 1;\n        $this->tokens   = [];\n\n        while (!$this->isAtEnd()) {\n            $this->scanToken();\n        }\n\n        // Add EOF token\n        $this->tokens[] = new Token(\n            TokenType::EOF,\n            '',\n            $this->line,\n            $this->column,\n            $this->position,\n        );\n\n        return $this->tokens;\n    }\n\n    /**\n     * Scan and add the next token from the input.\n     *\n     * @throws TokenException If an invalid token is encountered\n     */\n    private function scanToken(): void\n    {\n        $this->skipWhitespace();\n\n        if ($this->isAtEnd()) {\n            return;\n        }\n\n        $start       = $this->position;\n        $startLine   = $this->line;\n        $startColumn = $this->column;\n\n        $char = $this->advance();\n\n        // Single-character tokens\n        switch ($char) {\n            case '(':\n                $this->addToken(TokenType::LPAREN, '(', $startLine, $startColumn, $start);\n\n                return;\n            case ')':\n                $this->addToken(TokenType::RPAREN, ')', $startLine, $startColumn, $start);\n\n                return;\n            case '[':\n                $this->addToken(TokenType::LBRACKET, '[', $startLine, $startColumn, $start);\n\n                return;\n            case ']':\n                $this->addToken(TokenType::RBRACKET, ']', $startLine, $startColumn, $start);\n\n                return;\n            case '{':\n                $this->addToken(TokenType::LBRACE, '{', $startLine, $startColumn, $start);\n\n                return;\n            case '}':\n                $this->addToken(TokenType::RBRACE, '}', $startLine, $startColumn, $start);\n\n                return;\n            case ',':\n                $this->addToken(TokenType::COMMA, ',', $startLine, $startColumn, $start);\n\n                return;\n            case '.':\n                $this->addToken(TokenType::DOT, '.', $startLine, $startColumn, $start);\n\n                return;\n            case '+':\n                $this->addToken(TokenType::PLUS, '+', $startLine, $startColumn, $start);\n\n                return;\n            case '-':\n                $this->addToken(TokenType::MINUS, '-', $startLine, $startColumn, $start);\n\n                return;\n            case '*':\n                $this->addToken(TokenType::MULTIPLY, '*', $startLine, $startColumn, $start);\n\n                return;\n            case '|':\n                $this->addToken(TokenType::PIPE, '|', $startLine, $startColumn, $start);\n\n                return;\n            case '&':\n                $this->addToken(TokenType::AMPERSAND, '&', $startLine, $startColumn, $start);\n\n                return;\n        }\n\n        // Multi-character operators\n        if ($char === '=') {\n            $this->addToken(TokenType::EQUALS, '=', $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        if ($char === '!') {\n            if ($this->match('=')) {\n                $this->addToken(TokenType::NOT_EQUALS, '!=', $startLine, $startColumn, $start);\n\n                return;\n            }\n            if ($this->match('~')) {\n                $this->addToken(TokenType::NOT_EQUIVALENT, '!~', $startLine, $startColumn, $start);\n\n                return;\n            }\n            throw TokenException::unexpectedCharacter('!', $startLine, $startColumn, $this->getContext($start));\n        }\n\n        if ($char === '~') {\n            $this->addToken(TokenType::EQUIVALENT, '~', $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        if ($char === '>') {\n            if ($this->match('=')) {\n                $this->addToken(TokenType::GREATER_EQUAL, '>=', $startLine, $startColumn, $start);\n            } else {\n                $this->addToken(TokenType::GREATER_THAN, '>', $startLine, $startColumn, $start);\n            }\n\n            return;\n        }\n\n        if ($char === '<') {\n            if ($this->match('=')) {\n                $this->addToken(TokenType::LESS_EQUAL, '<=', $startLine, $startColumn, $start);\n            } else {\n                $this->addToken(TokenType::LESS_THAN, '<', $startLine, $startColumn, $start);\n            }\n\n            return;\n        }\n\n        if ($char === '/') {\n            $this->addToken(TokenType::DIVIDE, '/', $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // String literals\n        if ($char === \"'\") {\n            $this->scanString($startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // DateTime and Time literals\n        if ($char === '@') {\n            $this->scanDateTime($startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // Reserved identifiers starting with $\n        if ($char === '$') {\n            $this->scanReservedIdentifier($startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // External constants starting with %\n        if ($char === '%') {\n            $this->scanExternalConstant($startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // Numbers\n        if ($this->isDigit($char)) {\n            $this->scanNumber($char, $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // Identifiers and keywords\n        if ($this->isAlpha($char) || $char === '_') {\n            $this->scanIdentifier($char, $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // If we get here, we have an unexpected character\n        throw TokenException::unexpectedCharacter($char, $startLine, $startColumn, $this->getContext($start));\n    }\n\n    /**\n     * Scan a string literal.\n     *\n     * @throws TokenException If the string is unterminated or contains invalid escapes\n     */\n    private function scanString(int $startLine, int $startColumn, int $start): void\n    {\n        $value = '';\n\n        while (!$this->isAtEnd() && $this->peek() !== \"'\") {\n            if ($this->peek() === '\\\\') {\n                $this->advance(); // consume backslash\n                $escaped = $this->advance();\n\n                $value .= match ($escaped) {\n                    \"'\"     => \"'\",\n                    '\"'     => '\"',\n                    '\\\\'    => '\\\\',\n                    't'     => \"\\t\",\n                    'n'     => \"\\n\",\n                    'r'     => \"\\r\",\n                    'f'     => \"\\f\",\n                    'u'     => $this->scanUnicodeEscape($startLine, $startColumn),\n                    default => throw TokenException::invalidEscapeSequence('\\\\' . $escaped, $this->line, $this->column - 1, $this->getContext($start))\n                };\n            } else {\n                $value .= $this->advance();\n            }\n        }\n\n        if ($this->isAtEnd()) {\n            throw TokenException::unterminatedString($startLine, $startColumn, $this->getContext($start));\n        }\n\n        // Consume closing quote\n        $this->advance();\n\n        $this->addToken(TokenType::STRING, $value, $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Scan a Unicode escape sequence (\\uXXXX).\n     *\n     * @throws TokenException If the Unicode sequence is invalid\n     */\n    private function scanUnicodeEscape(int $startLine, int $startColumn): string\n    {\n        $hex = '';\n        for ($i = 0; $i < 4; ++$i) {\n            if ($this->isAtEnd() || !$this->isHexDigit($this->peek())) {\n                throw TokenException::invalidEscapeSequence('\\\\u' . $hex, $this->line, $this->column, '');\n            }\n            $hex .= $this->advance();\n        }\n\n        return mb_chr((int) hexdec($hex), 'UTF-8');\n    }\n\n    /**\n     * Scan a number literal (integer, decimal, or scientific notation).\n     */\n    private function scanNumber(string $firstChar, int $startLine, int $startColumn, int $start): void\n    {\n        $value = $firstChar;\n\n        // Consume integer part\n        while ($this->isDigit($this->peek())) {\n            $value .= $this->advance();\n        }\n\n        // Check for decimal part\n        if ($this->peek() === '.' && $this->isDigit($this->peek(1))) {\n            $value .= $this->advance(); // consume '.'\n            while ($this->isDigit($this->peek())) {\n                $value .= $this->advance();\n            }\n        }\n\n        // Check for scientific notation\n        if ($this->peek() === 'e' || $this->peek() === 'E') {\n            $value .= $this->advance(); // consume 'e' or 'E'\n            if ($this->peek() === '+' || $this->peek() === '-') {\n                $value .= $this->advance();\n            }\n            if (!$this->isDigit($this->peek())) {\n                throw TokenException::invalidNumber($value, $startLine, $startColumn, $this->getContext($start));\n            }\n            while ($this->isDigit($this->peek())) {\n                $value .= $this->advance();\n            }\n        }\n\n        // Check for quantity unit\n        if ($this->peek() === ' ' && $this->peek(1) === \"'\") {\n            $this->advance(); // consume space\n            $this->advance(); // consume opening quote\n\n            $unit = '';\n            while (!$this->isAtEnd() && $this->peek() !== \"'\") {\n                $unit .= $this->advance();\n            }\n\n            if ($this->isAtEnd()) {\n                throw TokenException::unterminatedString($startLine, $startColumn, $this->getContext($start));\n            }\n\n            $this->advance(); // consume closing quote\n\n            $this->addToken(TokenType::QUANTITY, $value . \" '\" . $unit . \"'\", $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        $this->addToken(TokenType::NUMBER, $value, $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Scan a DateTime or Time literal.\n     */\n    private function scanDateTime(int $startLine, int $startColumn, int $start): void\n    {\n        $value = '@';\n\n        // Check for Time literal (@T...)\n        if ($this->peek() === 'T') {\n            $value .= $this->advance();\n            // Scan time part\n            while (!$this->isAtEnd() && ($this->isDigit($this->peek()) || $this->peek() === ':' || $this->peek() === '.')) {\n                $value .= $this->advance();\n            }\n            $this->addToken(TokenType::TIME, $value, $startLine, $startColumn, $start);\n\n            return;\n        }\n\n        // Scan date part (YYYY-MM-DD)\n        while (!$this->isAtEnd() && ($this->isDigit($this->peek()) || $this->peek() === '-')) {\n            $value .= $this->advance();\n        }\n\n        // Check for time part\n        if ($this->peek() === 'T') {\n            $value .= $this->advance();\n            // Scan time and timezone\n            while (!$this->isAtEnd() && ($this->isDigit($this->peek()) || $this->peek() === ':' || $this->peek() === '.' || $this->peek() === '+' || $this->peek() === '-' || $this->peek() === 'Z')) {\n                $value .= $this->advance();\n            }\n        }\n\n        $this->addToken(TokenType::DATETIME, $value, $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Scan a reserved identifier ($this, $index, $total).\n     */\n    private function scanReservedIdentifier(int $startLine, int $startColumn, int $start): void\n    {\n        $value = '$';\n\n        while ($this->isAlphaNumeric($this->peek())) {\n            $value .= $this->advance();\n        }\n\n        $type = match ($value) {\n            '$this'  => TokenType::THIS,\n            '$index' => TokenType::INDEX,\n            '$total' => TokenType::TOTAL,\n            default  => TokenType::IDENTIFIER, // Treat as regular identifier if not recognized\n        };\n\n        $this->addToken($type, $value, $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Scan an external constant (%identifier).\n     */\n    private function scanExternalConstant(int $startLine, int $startColumn, int $start): void\n    {\n        $this->addToken(TokenType::PERCENT, '%', $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Scan an identifier or keyword.\n     */\n    private function scanIdentifier(string $firstChar, int $startLine, int $startColumn, int $start): void\n    {\n        $value = $firstChar;\n\n        while ($this->isAlphaNumeric($this->peek())) {\n            $value .= $this->advance();\n        }\n\n        // Check if it's a keyword\n        $type = self::KEYWORDS[strtolower($value)] ?? TokenType::IDENTIFIER;\n\n        $this->addToken($type, $value, $startLine, $startColumn, $start);\n    }\n\n    /**\n     * Add a token to the tokens list.\n     */\n    private function addToken(TokenType $type, string $value, int $line, int $column, int $position): void\n    {\n        $this->tokens[] = new Token($type, $value, $line, $column, $position);\n    }\n\n    /**\n     * Skip whitespace characters.\n     */\n    private function skipWhitespace(): void\n    {\n        while (!$this->isAtEnd()) {\n            $char = $this->peek();\n            if ($char === ' ' || $char === \"\\t\" || $char === \"\\r\" || $char === \"\\n\") {\n                $this->advance();\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Advance to the next character and return it.\n     */\n    private function advance(): string\n    {\n        if ($this->isAtEnd()) {\n            return \"\\0\";\n        }\n\n        $char = $this->input[$this->position++];\n\n        if ($char === \"\\n\") {\n            ++$this->line;\n            $this->column = 1;\n        } else {\n            ++$this->column;\n        }\n\n        return $char;\n    }\n\n    /**\n     * Peek at the current character without advancing.\n     */\n    private function peek(int $offset = 0): string\n    {\n        $pos = $this->position + $offset;\n        if ($pos >= strlen($this->input)) {\n            return \"\\0\";\n        }\n\n        return $this->input[$pos];\n    }\n\n    /**\n     * Check if the current character matches the expected character and advance if it does.\n     */\n    private function match(string $expected): bool\n    {\n        if ($this->isAtEnd() || $this->peek() !== $expected) {\n            return false;\n        }\n        $this->advance();\n\n        return true;\n    }\n\n    /**\n     * Check if we've reached the end of the input.\n     */\n    private function isAtEnd(): bool\n    {\n        return $this->position >= strlen($this->input);\n    }\n\n    /**\n     * Check if a character is a digit.\n     */\n    private function isDigit(string $char): bool\n    {\n        return $char >= '0' && $char <= '9';\n    }\n\n    /**\n     * Check if a character is a hexadecimal digit.\n     */\n    private function isHexDigit(string $char): bool\n    {\n        return ($char >= '0' && $char <= '9')\n               || ($char >= 'a' && $char <= 'f')\n               || ($char >= 'A' && $char <= 'F');\n    }\n\n    /**\n     * Check if a character is alphabetic.\n     */\n    private function isAlpha(string $char): bool\n    {\n        return ($char >= 'a' && $char <= 'z')\n               || ($char >= 'A' && $char <= 'Z')\n               || $char === '_';\n    }\n\n    /**\n     * Check if a character is alphanumeric.\n     */\n    private function isAlphaNumeric(string $char): bool\n    {\n        return $this->isAlpha($char) || $this->isDigit($char);\n    }\n\n    /**\n     * Get context string around a position for error messages.\n     */\n    private function getContext(int $position, int $radius = 20): string\n    {\n        $start = max(0, $position - $radius);\n        $end   = min(strlen($this->input), $position + $radius);\n\n        $context = substr($this->input, $start, $end - $start);\n\n        if ($start > 0) {\n            $context = '...' . $context;\n        }\n        if ($end < strlen($this->input)) {\n            $context .= '...';\n        }\n\n        return $context;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Parser/FHIRPathParser.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\SyntaxException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\BinaryOperatorNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\CollectionLiteralNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExternalConstantNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\FunctionCallNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\IdentifierNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\IndexerNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\LiteralNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\MemberAccessNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\TypeExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\UnaryOperatorNode;\n\n/**\n * Recursive descent parser for FHIRPath expressions.\n *\n * Converts a sequence of tokens from the lexer into an Abstract Syntax Tree (AST)\n * following the FHIRPath 2.0 grammar. Handles operator precedence, function calls,\n * member access, and all FHIRPath constructs.\n *\n * Grammar (from FHIRPath spec):\n * - expression: term (('|') term)*\n * - term: factor (('and' | 'or' | 'xor' | 'implies') factor)*\n * - factor: invocation (('*' | '/' | 'div' | 'mod') invocation)*\n * - invocation: primary (typeExpression | invocationExpression)*\n * - primary: literal | externalConstant | '(' expression ')' | '{' '}' | function\n *\n * @author FHIR Tools Contributors\n */\nclass FHIRPathParser\n{\n    /** @var array<Token> */\n    private array $tokens = [];\n\n    private int $current = 0;\n\n    /**\n     * Parse a FHIRPath expression from tokens.\n     *\n     * @param array<Token> $tokens The tokens to parse\n     *\n     * @return ExpressionNode The root node of the AST\n     *\n     * @throws SyntaxException If parsing fails\n     */\n    public function parse(array $tokens): ExpressionNode\n    {\n        $this->tokens  = $tokens;\n        $this->current = 0;\n\n        $expression = $this->parseExpression();\n\n        // Ensure we've consumed all tokens except EOF\n        if (!$this->isAtEnd()) {\n            throw SyntaxException::unexpectedToken('end of expression', $this->peek()->toString(), $this->peek()->line, $this->peek()->column);\n        }\n\n        return $expression;\n    }\n\n    /**\n     * Parse an expression (top-level rule).\n     * expression: term (('|') term)*\n     */\n    private function parseExpression(): ExpressionNode\n    {\n        $left = $this->parseTerm();\n\n        while ($this->match(TokenType::PIPE)) {\n            $operator = $this->previous();\n            $right    = $this->parseTerm();\n            $left     = new BinaryOperatorNode(\n                $left,\n                $operator->type,\n                $right,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        return $left;\n    }\n\n    /**\n     * Parse a term (logical operators).\n     * term: factor (('and' | 'or' | 'xor' | 'implies') factor)*\n     */\n    private function parseTerm(): ExpressionNode\n    {\n        $left = $this->parseFactor();\n\n        while ($this->match(TokenType::AND, TokenType::OR, TokenType::XOR, TokenType::IMPLIES)) {\n            $operator = $this->previous();\n            $right    = $this->parseFactor();\n            $left     = new BinaryOperatorNode(\n                $left,\n                $operator->type,\n                $right,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        return $left;\n    }\n\n    /**\n     * Parse a factor (multiplicative operators and comparisons).\n     * This combines multiple precedence levels for simplicity.\n     */\n    private function parseFactor(): ExpressionNode\n    {\n        $left = $this->parseUnary();\n\n        // Handle comparison operators\n        while ($this->match(\n            TokenType::EQUALS,\n            TokenType::NOT_EQUALS,\n            TokenType::EQUIVALENT,\n            TokenType::NOT_EQUIVALENT,\n            TokenType::GREATER_THAN,\n            TokenType::LESS_THAN,\n            TokenType::GREATER_EQUAL,\n            TokenType::LESS_EQUAL,\n            TokenType::IN,\n            TokenType::CONTAINS,\n        )) {\n            $operator = $this->previous();\n            $right    = $this->parseUnary();\n            $left     = new BinaryOperatorNode(\n                $left,\n                $operator->type,\n                $right,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        // Handle multiplicative operators\n        while ($this->match(TokenType::MULTIPLY, TokenType::DIVIDE, TokenType::DIV, TokenType::MOD)) {\n            $operator = $this->previous();\n            $right    = $this->parseUnary();\n            $left     = new BinaryOperatorNode(\n                $left,\n                $operator->type,\n                $right,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        // Handle additive operators\n        while ($this->match(TokenType::PLUS, TokenType::MINUS, TokenType::AMPERSAND)) {\n            $operator = $this->previous();\n            $right    = $this->parseUnary();\n            $left     = new BinaryOperatorNode(\n                $left,\n                $operator->type,\n                $right,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        return $left;\n    }\n\n    /**\n     * Parse unary operators.\n     */\n    private function parseUnary(): ExpressionNode\n    {\n        if ($this->match(TokenType::MINUS, TokenType::PLUS)) {\n            $operator = $this->previous();\n            $operand  = $this->parseUnary();\n\n            return new UnaryOperatorNode(\n                $operator->type,\n                $operand,\n                $operator->line,\n                $operator->column,\n            );\n        }\n\n        return $this->parseInvocation();\n    }\n\n    /**\n     * Parse an invocation (member access, indexer, type expressions).\n     * invocation: primary (typeExpression | invocationExpression)*\n     */\n    private function parseInvocation(): ExpressionNode\n    {\n        $expression = $this->parsePrimary();\n\n        while (true) {\n            // Handle type expressions (is, as)\n            if ($this->match(TokenType::IS, TokenType::AS)) {\n                $operator   = $this->previous();\n                $typeName   = $this->consume(TokenType::IDENTIFIER, 'type name');\n                $expression = new TypeExpressionNode(\n                    $expression,\n                    $operator->type,\n                    $typeName->value,\n                    $operator->line,\n                    $operator->column,\n                );\n                continue;\n            }\n\n            // Handle member access\n            if ($this->match(TokenType::DOT)) {\n                $dot        = $this->previous();\n                $member     = $this->parsePrimary();\n                $expression = new MemberAccessNode(\n                    $expression,\n                    $member,\n                    $dot->line,\n                    $dot->column,\n                );\n                continue;\n            }\n\n            // Handle indexer\n            if ($this->match(TokenType::LBRACKET)) {\n                $bracket = $this->previous();\n                $index   = $this->parseExpression();\n                $this->consume(TokenType::RBRACKET, ']');\n                $expression = new IndexerNode(\n                    $expression,\n                    $index,\n                    $bracket->line,\n                    $bracket->column,\n                );\n                continue;\n            }\n\n            break;\n        }\n\n        return $expression;\n    }\n\n    /**\n     * Parse a primary expression.\n     * primary: literal | externalConstant | '(' expression ')' | '{' '}' | function | identifier\n     */\n    private function parsePrimary(): ExpressionNode\n    {\n        // Literals\n        if ($this->peek()->type->isLiteral()) {\n            $token = $this->advance();\n            $value = match ($token->type) {\n                TokenType::BOOLEAN => $token->value === 'true',\n                TokenType::NULL    => null,\n                TokenType::NUMBER  => $this->parseNumber($token->value),\n                default            => $token->value,\n            };\n\n            return new LiteralNode($value, $token->type, $token->line, $token->column);\n        }\n\n        // External constants\n        if ($this->match(TokenType::PERCENT)) {\n            $percent = $this->previous();\n            $name    = $this->consume(TokenType::IDENTIFIER, 'constant name');\n\n            return new ExternalConstantNode($name->value, $percent->line, $percent->column);\n        }\n\n        // Parenthesized expression\n        if ($this->match(TokenType::LPAREN)) {\n            $paren      = $this->previous();\n            $expression = $this->parseExpression();\n            $this->consume(TokenType::RPAREN, ')');\n\n            return $expression;\n        }\n\n        // Empty collection\n        if ($this->match(TokenType::LBRACE)) {\n            $brace    = $this->previous();\n            $elements = [];\n\n            if (!$this->check(TokenType::RBRACE)) {\n                do {\n                    $elements[] = $this->parseExpression();\n                } while ($this->match(TokenType::COMMA));\n            }\n\n            $this->consume(TokenType::RBRACE, '}');\n\n            return new CollectionLiteralNode($elements, $brace->line, $brace->column);\n        }\n\n        // Reserved identifiers\n        if ($this->match(TokenType::THIS, TokenType::INDEX, TokenType::TOTAL)) {\n            $token = $this->previous();\n\n            return new IdentifierNode($token->value, $token->line, $token->column);\n        }\n\n        // Function call or identifier\n        if ($this->match(TokenType::IDENTIFIER)) {\n            $identifier = $this->previous();\n\n            // Check if it's a function call\n            if ($this->match(TokenType::LPAREN)) {\n                $parameters = [];\n\n                if (!$this->check(TokenType::RPAREN)) {\n                    do {\n                        $parameters[] = $this->parseExpression();\n                    } while ($this->match(TokenType::COMMA));\n                }\n\n                $this->consume(TokenType::RPAREN, ')');\n\n                return new FunctionCallNode(\n                    $identifier->value,\n                    $parameters,\n                    $identifier->line,\n                    $identifier->column,\n                );\n            }\n\n            // Just an identifier\n            return new IdentifierNode($identifier->value, $identifier->line, $identifier->column);\n        }\n\n        throw SyntaxException::unexpectedToken('expression', $this->peek()->toString(), $this->peek()->line, $this->peek()->column);\n    }\n\n    /**\n     * Parse a number value.\n     */\n    private function parseNumber(string $value): int|float\n    {\n        if (str_contains($value, '.') || str_contains($value, 'e') || str_contains($value, 'E')) {\n            return (float) $value;\n        }\n\n        return (int) $value;\n    }\n\n    /**\n     * Check if current token matches any of the given types and advance if so.\n     */\n    private function match(TokenType ...$types): bool\n    {\n        foreach ($types as $type) {\n            if ($this->check($type)) {\n                $this->advance();\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if current token is of the given type.\n     */\n    private function check(TokenType $type): bool\n    {\n        if ($this->isAtEnd()) {\n            return false;\n        }\n\n        return $this->peek()->type === $type;\n    }\n\n    /**\n     * Advance to the next token and return the previous one.\n     */\n    private function advance(): Token\n    {\n        if (!$this->isAtEnd()) {\n            ++$this->current;\n        }\n\n        return $this->previous();\n    }\n\n    /**\n     * Check if we're at the end of tokens.\n     */\n    private function isAtEnd(): bool\n    {\n        return $this->peek()->type === TokenType::EOF;\n    }\n\n    /**\n     * Get the current token without advancing.\n     */\n    private function peek(): Token\n    {\n        return $this->tokens[$this->current];\n    }\n\n    /**\n     * Get the previous token.\n     */\n    private function previous(): Token\n    {\n        return $this->tokens[$this->current - 1];\n    }\n\n    /**\n     * Consume a token of the expected type or throw an error.\n     */\n    private function consume(TokenType $type, string $description): Token\n    {\n        if ($this->check($type)) {\n            return $this->advance();\n        }\n\n        throw SyntaxException::unexpectedToken($description, $this->peek()->toString(), $this->peek()->line, $this->peek()->column);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Parser/Token.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser;\n\n/**\n * Represents a single token in a FHIRPath expression.\n *\n * Tokens are immutable and contain information about the token type,\n * its value, and its position in the source expression for error reporting.\n *\n * @author FHIR Tools Contributors\n */\nreadonly class Token\n{\n    /**\n     * Create a new token.\n     *\n     * @param TokenType $type     The type of this token\n     * @param string    $value    The literal value of this token from the source\n     * @param int       $line     The line number where this token appears (1-indexed)\n     * @param int       $column   The column number where this token starts (1-indexed)\n     * @param int       $position The absolute character position in the source (0-indexed)\n     */\n    public function __construct(\n        public TokenType $type,\n        public string $value,\n        public int $line,\n        public int $column,\n        public int $position\n    ) {\n    }\n\n    /**\n     * Check if this token is of a specific type.\n     *\n     * @param TokenType $type The type to check against\n     *\n     * @return bool True if this token matches the specified type\n     */\n    public function is(TokenType $type): bool\n    {\n        return $this->type === $type;\n    }\n\n    /**\n     * Check if this token is one of several types.\n     *\n     * @param TokenType ...$types One or more types to check against\n     *\n     * @return bool True if this token matches any of the specified types\n     */\n    public function isOneOf(TokenType ...$types): bool\n    {\n        foreach ($types as $type) {\n            if ($this->type === $type) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get a string representation of this token for debugging.\n     *\n     * @return string A formatted string showing the token's type, value, and position\n     */\n    public function toString(): string\n    {\n        return sprintf(\n            '%s(%s) at %d:%d',\n            $this->type->value,\n            $this->value !== '' ? $this->value : '<empty>',\n            $this->line,\n            $this->column,\n        );\n    }\n\n    /**\n     * Magic method to convert token to string.\n     *\n     * @return string The token's string representation\n     */\n    public function __toString(): string\n    {\n        return $this->toString();\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Parser/TokenType.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser;\n\n/**\n * FHIRPath token types enumeration.\n *\n * Defines all possible token types that can appear in a FHIRPath expression,\n * including literals, keywords, operators, delimiters, and special tokens.\n *\n * @author FHIR Tools Contributors\n */\nenum TokenType: string\n{\n    // Literals\n    case STRING   = 'STRING';\n    case NUMBER   = 'NUMBER';\n    case BOOLEAN  = 'BOOLEAN';\n    case NULL     = 'NULL';\n    case DATETIME = 'DATETIME';\n    case TIME     = 'TIME';\n    case QUANTITY = 'QUANTITY';\n\n    // Identifiers and Keywords\n    case IDENTIFIER = 'IDENTIFIER';\n    case AND        = 'AND';\n    case OR         = 'OR';\n    case XOR        = 'XOR';\n    case IMPLIES    = 'IMPLIES';\n    case AS         = 'AS';\n    case IS         = 'IS';\n    case IN         = 'IN';\n    case CONTAINS   = 'CONTAINS';\n    case DIV        = 'DIV';\n    case MOD        = 'MOD';\n\n    // Reserved Identifiers\n    case THIS  = 'THIS';           // $this\n    case INDEX = 'INDEX';         // $index\n    case TOTAL = 'TOTAL';         // $total\n\n    // Comparison Operators\n    case EQUALS         = 'EQUALS';                  // =\n    case NOT_EQUALS     = 'NOT_EQUALS';          // !=\n    case EQUIVALENT     = 'EQUIVALENT';          // ~\n    case NOT_EQUIVALENT = 'NOT_EQUIVALENT';  // !~\n    case GREATER_THAN   = 'GREATER_THAN';      // >\n    case LESS_THAN      = 'LESS_THAN';            // <\n    case GREATER_EQUAL  = 'GREATER_EQUAL';    // >=\n    case LESS_EQUAL     = 'LESS_EQUAL';          // <=\n\n    // Arithmetic Operators\n    case PLUS     = 'PLUS';                      // +\n    case MINUS    = 'MINUS';                    // -\n    case MULTIPLY = 'MULTIPLY';              // *\n    case DIVIDE   = 'DIVIDE';                  // /\n\n    // Delimiters\n    case DOT      = 'DOT';                        // .\n    case COMMA    = 'COMMA';                    // ,\n    case LPAREN   = 'LPAREN';                  // (\n    case RPAREN   = 'RPAREN';                  // )\n    case LBRACKET = 'LBRACKET';              // [\n    case RBRACKET = 'RBRACKET';              // ]\n    case LBRACE   = 'LBRACE';                  // {\n    case RBRACE   = 'RBRACE';                  // }\n\n    // Special\n    case PIPE      = 'PIPE';                      // |\n    case AMPERSAND = 'AMPERSAND';            // &\n    case PERCENT   = 'PERCENT';                // % (external constant prefix)\n    case DOLLAR    = 'DOLLAR';                  // $ (reserved identifier prefix)\n\n    // End of file\n    case EOF = 'EOF';\n\n    /**\n     * Check if this token type is a keyword.\n     */\n    public function isKeyword(): bool\n    {\n        return match ($this) {\n            self::AND, self::OR, self::XOR, self::IMPLIES,\n            self::AS, self::IS, self::IN, self::CONTAINS,\n            self::DIV, self::MOD => true,\n            default => false,\n        };\n    }\n\n    /**\n     * Check if this token type is an operator.\n     */\n    public function isOperator(): bool\n    {\n        return match ($this) {\n            self::EQUALS, self::NOT_EQUALS, self::EQUIVALENT, self::NOT_EQUIVALENT,\n            self::GREATER_THAN, self::LESS_THAN, self::GREATER_EQUAL, self::LESS_EQUAL,\n            self::PLUS, self::MINUS, self::MULTIPLY, self::DIVIDE,\n            self::PIPE, self::AMPERSAND => true,\n            default => false,\n        };\n    }\n\n    /**\n     * Check if this token type is a literal.\n     */\n    public function isLiteral(): bool\n    {\n        return match ($this) {\n            self::STRING, self::NUMBER, self::BOOLEAN, self::NULL,\n            self::DATETIME, self::TIME, self::QUANTITY => true,\n            default => false,\n        };\n    }\n\n    /**\n     * Check if this token type is a delimiter.\n     */\n    public function isDelimiter(): bool\n    {\n        return match ($this) {\n            self::DOT, self::COMMA, self::LPAREN, self::RPAREN,\n            self::LBRACKET, self::RBRACKET, self::LBRACE, self::RBRACE => true,\n            default => false,\n        };\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Service/CompiledExpression.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Service;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\FHIRPathEvaluator;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\EvaluationException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\n\n/**\n * Represents a compiled FHIRPath expression that can be evaluated multiple times.\n *\n * Pre-parses and caches the expression AST for improved performance when evaluating\n * the same expression against multiple resources. This avoids re-parsing the expression\n * on each evaluation.\n *\n * @author Ardenexal\n */\nclass CompiledExpression\n{\n    /**\n     * Create a new compiled expression.\n     *\n     * @param ExpressionNode    $ast        The pre-parsed expression AST\n     * @param FHIRPathEvaluator $evaluator  The evaluator to use\n     * @param string            $expression The original expression string\n     */\n    public function __construct(\n        private readonly ExpressionNode $ast,\n        private readonly FHIRPathEvaluator $evaluator,\n        private readonly string $expression\n    ) {\n    }\n\n    /**\n     * Evaluate the compiled expression against a resource.\n     *\n     * @param mixed                  $resource The FHIR resource or data to evaluate against\n     * @param EvaluationContext|null $context  Optional evaluation context\n     *\n     * @return Collection The result collection\n     *\n     * @throws EvaluationException If evaluation fails\n     */\n    public function evaluate(mixed $resource, ?EvaluationContext $context = null): Collection\n    {\n        return $this->evaluator->evaluate($this->ast, $resource, $context);\n    }\n\n    /**\n     * Get the original expression string.\n     *\n     * @return string The expression string\n     */\n    public function getExpression(): string\n    {\n        return $this->expression;\n    }\n\n    /**\n     * Get the parsed AST.\n     *\n     * @return ExpressionNode The expression AST\n     */\n    public function getAst(): ExpressionNode\n    {\n        return $this->ast;\n    }\n\n    /**\n     * Get the string representation of this compiled expression.\n     *\n     * @return string The expression string\n     */\n    public function __toString(): string\n    {\n        return $this->expression;\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Service/FHIRPathService.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Service;\n\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Cache\\ExpressionCacheInterface;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Cache\\InMemoryExpressionCache;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\Collection;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\EvaluationContext;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Evaluator\\FHIRPathEvaluator;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Exception\\FHIRPathException;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Expression\\ExpressionNode;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\FHIRPathLexer;\nuse Ardenexal\\FHIRTools\\Component\\FHIRPath\\Parser\\FHIRPathParser;\n\n/**\n * High-level service for FHIRPath expression evaluation.\n *\n * Provides a convenient API for evaluating FHIRPath expressions against FHIR resources.\n * Handles lexing, parsing, and evaluation in a single call, with support for expression\n * validation, compilation, and caching for improved performance.\n *\n * @author Ardenexal\n */\nclass FHIRPathService\n{\n    private FHIRPathLexer $lexer;\n\n    private FHIRPathParser $parser;\n\n    private FHIRPathEvaluator $evaluator;\n\n    private ExpressionCacheInterface $cache;\n\n    /**\n     * Create a new FHIRPath service.\n     *\n     * @param ExpressionCacheInterface|null $cache Optional cache implementation (defaults to in-memory cache)\n     */\n    public function __construct(?ExpressionCacheInterface $cache = null)\n    {\n        $this->lexer     = new FHIRPathLexer();\n        $this->parser    = new FHIRPathParser();\n        $this->evaluator = new FHIRPathEvaluator();\n        $this->cache     = $cache ?? new InMemoryExpressionCache();\n    }\n\n    /**\n     * Evaluate a FHIRPath expression against a resource.\n     *\n     * Uses caching to avoid re-parsing frequently used expressions.\n     *\n     * @param string                 $expression The FHIRPath expression to evaluate\n     * @param mixed                  $resource   The FHIR resource or data to evaluate against\n     * @param EvaluationContext|null $context    Optional evaluation context\n     *\n     * @return Collection The result collection\n     *\n     * @throws FHIRPathException If the expression is invalid or evaluation fails\n     */\n    public function evaluate(string $expression, mixed $resource, ?EvaluationContext $context = null): Collection\n    {\n        $compiled = $this->getOrCompile($expression);\n\n        return $compiled->evaluate($resource, $context);\n    }\n\n    /**\n     * Validate a FHIRPath expression without evaluating it.\n     *\n     * Checks if the expression is syntactically valid by attempting to parse it.\n     *\n     * @param string $expression The FHIRPath expression to validate\n     *\n     * @return bool True if the expression is valid, false otherwise\n     */\n    public function validate(string $expression): bool\n    {\n        try {\n            $this->parse($expression);\n\n            return true;\n        } catch (FHIRPathException) {\n            return false;\n        }\n    }\n\n    /**\n     * Compile a FHIRPath expression for repeated evaluation.\n     *\n     * Parses the expression once and returns a compiled expression that can be\n     * evaluated multiple times against different resources for improved performance.\n     * The compiled expression is also cached for future use.\n     *\n     * @param string $expression The FHIRPath expression to compile\n     *\n     * @return CompiledExpression The compiled expression\n     *\n     * @throws FHIRPathException If the expression is invalid\n     */\n    public function compile(string $expression): CompiledExpression\n    {\n        return $this->getOrCompile($expression);\n    }\n\n    /**\n     * Get the expression cache.\n     *\n     * @return ExpressionCacheInterface The cache instance\n     */\n    public function getCache(): ExpressionCacheInterface\n    {\n        return $this->cache;\n    }\n\n    /**\n     * Clear the expression cache.\n     */\n    public function clearCache(): void\n    {\n        $this->cache->clear();\n    }\n\n    /**\n     * Get cache statistics.\n     *\n     * @return array{hits: int, misses: int, size: int} Cache statistics\n     */\n    public function getCacheStats(): array\n    {\n        return $this->cache->getStats();\n    }\n\n    /**\n     * Get or compile an expression, using cache when available.\n     *\n     * @param string $expression The FHIRPath expression\n     *\n     * @return CompiledExpression The compiled expression\n     *\n     * @throws FHIRPathException If the expression is invalid\n     */\n    private function getOrCompile(string $expression): CompiledExpression\n    {\n        // Check cache first\n        $cached = $this->cache->get($expression);\n        if ($cached !== null) {\n            return $cached;\n        }\n\n        // Parse and compile\n        $ast      = $this->parse($expression);\n        $compiled = new CompiledExpression($ast, $this->evaluator, $expression);\n\n        // Store in cache\n        $this->cache->set($expression, $compiled);\n\n        return $compiled;\n    }\n\n    /**\n     * Parse a FHIRPath expression into an AST.\n     *\n     * @param string $expression The FHIRPath expression to parse\n     *\n     * @return ExpressionNode The root node of the AST\n     *\n     * @throws FHIRPathException If parsing fails\n     */\n    private function parse(string $expression): ExpressionNode\n    {\n        $tokens = $this->lexer->tokenize($expression);\n\n        return $this->parser->parse($tokens);\n    }\n}\n",
        "/fhir/Component/FHIRPath/src/Type/FHIRTypeResolver.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\FHIRPath\\Type;\n\nuse Ardenexal\\FHIRTools\\Component\\CodeGeneration\\Attributes\\FHIRPrimitive;\n\n/**\n * Resolves and validates FHIR types using the generated FHIR models.\n *\n * This class integrates the FHIRPath type system with the generated FHIR models\n * from src/Component/Models (or wherever they are generated). It provides\n * type checking, validation, and inference based on actual FHIR resource classes.\n *\n * @author Ardenexal\n */\nclass FHIRTypeResolver\n{\n    /**\n     * Primitive FHIR types mapping.\n     *\n     * @var array<string, string>\n     */\n    private const PRIMITIVE_TYPES = [\n        'boolean'      => 'boolean',\n        'string'       => 'string',\n        'integer'      => 'integer',\n        'decimal'      => 'float',\n        'date'         => 'string',\n        'dateTime'     => 'string',\n        'time'         => 'string',\n        'uri'          => 'string',\n        'url'          => 'string',\n        'canonical'    => 'string',\n        'code'         => 'string',\n        'oid'          => 'string',\n        'id'           => 'string',\n        'uuid'         => 'string',\n        'markdown'     => 'string',\n        'base64Binary' => 'string',\n        'instant'      => 'string',\n        'unsignedInt'  => 'integer',\n        'positiveInt'  => 'integer',\n    ];\n\n    /**\n     * Infer the FHIR type from a PHP value.\n     *\n     * @param mixed $value The value to infer the type from\n     *\n     * @return string The inferred FHIR type name\n     */\n    public function inferType(mixed $value): string\n    {\n        if ($value === null) {\n            return 'undefined';\n        }\n\n        if (is_bool($value)) {\n            return 'boolean';\n        }\n\n        if (is_int($value)) {\n            return 'integer';\n        }\n\n        if (is_float($value)) {\n            return 'decimal';\n        }\n\n        if (is_string($value)) {\n            return 'string';\n        }\n\n        if (is_object($value)) {\n            // Check if the object has a FHIRPrimitive attribute\n            $ref   = new \\ReflectionClass($value);\n            $attrs = $ref->getAttributes(FHIRPrimitive::class);\n\n            if (!empty($attrs)) {\n                /** @var FHIRPrimitive $primitive */\n                $primitive = $attrs[0]->newInstance();\n\n                return $primitive->primitiveType;\n            }\n\n            // Get the class name and extract the FHIR type\n            $class = get_class($value);\n\n            // Check if it's a generated FHIR model\n            if (str_contains($class, '\\\\FHIR\\\\') || str_contains($class, '\\\\Models\\\\')) {\n                // Extract the type name from the class name\n                $parts = explode('\\\\', $class);\n\n                return end($parts);\n            }\n\n            return 'Resource';\n        }\n\n        if (is_array($value)) {\n            return 'Collection';\n        }\n\n        return 'Any';\n    }\n\n    /**\n     * Check if a value is of a specific FHIR type.\n     *\n     * @param mixed  $value    The value to check\n     * @param string $typeName The FHIR type name to check against\n     *\n     * @return bool True if the value is of the specified type\n     */\n    public function isOfType(mixed $value, string $typeName): bool\n    {\n        $actualType = $this->inferType($value);\n\n        // Exact match\n        if ($actualType === $typeName) {\n            return true;\n        }\n\n        // Case-insensitive match\n        if (strcasecmp($actualType, $typeName) === 0) {\n            return true;\n        }\n\n        // Check for type compatibility\n        if ($typeName === 'Any') {\n            return true;\n        }\n\n        // Check if integer is compatible with decimal (case-insensitive)\n        if (strcasecmp($typeName, 'decimal') === 0 && $actualType === 'integer') {\n            return true;\n        }\n\n        // Check if value is an instance of the FHIR resource type\n        if (is_object($value)) {\n            $class = get_class($value);\n            if (str_ends_with($class, '\\\\' . $typeName)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Attempt to cast a value to a specific FHIR type.\n     *\n     * @param mixed  $value    The value to cast\n     * @param string $typeName The target FHIR type name\n     *\n     * @return mixed The casted value\n     *\n     * @throws \\InvalidArgumentException If the value cannot be cast to the type\n     */\n    public function castToType(mixed $value, string $typeName): mixed\n    {\n        // If already the correct type, return as-is\n        if ($this->isOfType($value, $typeName)) {\n            return $value;\n        }\n\n        // Extract value from FHIR primitives before casting\n        $castValue = $value;\n        if (is_object($value)) {\n            $ref   = new \\ReflectionClass($value);\n            $attrs = $ref->getAttributes(FHIRPrimitive::class);\n\n            if (!empty($attrs) && property_exists($value, 'value')) {\n                $castValue = $value->value;\n            }\n        }\n\n        // Normalize typeName to lowercase for matching\n        $normalizedType = strtolower($typeName);\n\n        // Primitive type casting\n        return match ($normalizedType) {\n            'boolean' => $this->castToBoolean($castValue),\n            'string'  => $this->castToString($castValue),\n            'integer' => $this->castToInteger($castValue),\n            'decimal' => $this->castToDecimal($castValue),\n            default   => throw new \\InvalidArgumentException(sprintf('Cannot cast value to type \"%s\"', $typeName)),\n        };\n    }\n\n    /**\n     * Check if a type name is a primitive FHIR type.\n     *\n     * @param string $typeName\n     *\n     * @return bool\n     */\n    public function isPrimitiveType(string $typeName): bool\n    {\n        return isset(self::PRIMITIVE_TYPES[$typeName]);\n    }\n\n    /**\n     * Get the PHP type for a FHIR primitive type.\n     *\n     * @param string $fhirType\n     *\n     * @return string|null\n     */\n    public function getPhpType(string $fhirType): ?string\n    {\n        return self::PRIMITIVE_TYPES[$fhirType] ?? null;\n    }\n\n    /**\n     * Cast value to boolean.\n     *\n     * @param mixed $value\n     *\n     * @return bool\n     */\n    private function castToBoolean(mixed $value): bool\n    {\n        if (is_bool($value)) {\n            return $value;\n        }\n\n        if (is_string($value)) {\n            $lower = strtolower($value);\n            if ($lower === 'true') {\n                return true;\n            }\n            if ($lower === 'false') {\n                return false;\n            }\n        }\n\n        throw new \\InvalidArgumentException('Cannot cast value to boolean');\n    }\n\n    /**\n     * Cast value to string.\n     *\n     * @param mixed $value\n     *\n     * @return string\n     */\n    private function castToString(mixed $value): string\n    {\n        if (is_string($value)) {\n            return $value;\n        }\n\n        if (is_scalar($value)) {\n            return (string) $value;\n        }\n\n        throw new \\InvalidArgumentException('Cannot cast value to string');\n    }\n\n    /**\n     * Cast value to integer.\n     *\n     * @param mixed $value\n     *\n     * @return int\n     */\n    private function castToInteger(mixed $value): int\n    {\n        if (is_int($value)) {\n            return $value;\n        }\n\n        if (is_float($value)) {\n            return (int) $value;\n        }\n\n        if (is_string($value) && is_numeric($value)) {\n            return (int) $value;\n        }\n\n        throw new \\InvalidArgumentException('Cannot cast value to integer');\n    }\n\n    /**\n     * Cast value to decimal.\n     *\n     * @param mixed $value\n     *\n     * @return float\n     */\n    private function castToDecimal(mixed $value): float\n    {\n        if (is_float($value)) {\n            return $value;\n        }\n\n        if (is_int($value)) {\n            return (float) $value;\n        }\n\n        if (is_string($value) && is_numeric($value)) {\n            return (float) $value;\n        }\n\n        throw new \\InvalidArgumentException('Cannot cast value to decimal');\n    }\n}\n",
        "/fhir/src/Exception/FHIRToolsException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\nuse Exception;\n\n/**\n * Base exception class for all FHIR Tools related errors\n *\n * This abstract class provides a foundation for all FHIR Tools exceptions,\n * offering enhanced error context management and formatted error reporting.\n * All specific exception types should extend this class to maintain consistency\n * in error handling throughout the application.\n *\n * Features:\n * - Context information storage for debugging\n * - Formatted error messages with context\n * - Fluent interface for adding context data\n * - Consistent error structure across all FHIR Tools exceptions\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nabstract class FHIRToolsException extends \\Exception\n{\n    /**\n     * Additional context information about the error\n     *\n     * This array stores key-value pairs that provide additional context\n     * about the error, such as element paths, resource URLs, or other\n     * relevant debugging information.\n     *\n     * @var array<string, mixed>\n     */\n    protected array $context = [];\n\n    /**\n     * Construct a new FHIR Tools exception with optional context\n     *\n     * @param string               $message  The exception message\n     * @param int                  $code     The exception code\n     * @param \\Exception|null      $previous The previous exception for chaining\n     * @param array<string, mixed> $context  Additional context information\n     */\n    public function __construct(string $message = '', int $code = 0, ?\\Exception $previous = null, array $context = [])\n    {\n        parent::__construct($message, $code, $previous);\n        $this->context = $context;\n    }\n\n    /**\n     * Get additional context information about the error\n     *\n     * Returns the complete context array containing all additional\n     * information that was provided when the exception was created\n     * or added later via addContext().\n     *\n     * @return array<string, mixed> The context information\n     */\n    public function getContext(): array\n    {\n        return $this->context;\n    }\n\n    /**\n     * Add context information to the exception\n     *\n     * This method allows adding additional context information after\n     * the exception has been created. It uses a fluent interface\n     * pattern for easy chaining of multiple context additions.\n     *\n     * @param string $key   The context key\n     * @param mixed  $value The context value\n     *\n     * @return static Returns self for method chaining\n     */\n    public function addContext(string $key, mixed $value): static\n    {\n        $this->context[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * Get a formatted error message with context\n     *\n     * Returns the exception message along with a formatted representation\n     * of the context information. This is useful for logging and debugging\n     * as it provides all available information in a readable format.\n     *\n     * @return string The formatted message with context\n     */\n    public function getFormattedMessage(): string\n    {\n        $message = $this->getMessage();\n\n        if (!empty($this->context)) {\n            $contextString = json_encode($this->context, JSON_PRETTY_PRINT);\n            $message .= \"\\nContext: \" . $contextString;\n        }\n\n        return $message;\n    }\n}\n",
        "/fhir/src/Exception/GenerationException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\n/**\n * Exception thrown when FHIR code generation fails\n *\n * This exception is thrown when FHIR code generation encounters errors,\n * such as invalid StructureDefinitions, missing references, or unsupported\n * FHIR versions.\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nclass GenerationException extends FHIRToolsException\n{\n    /**\n     * Create exception for invalid StructureDefinition scenarios\n     *\n     * @param string $structureDefinitionUrl The URL of the invalid StructureDefinition\n     * @param string $reason                 The reason why it's invalid\n     *\n     * @return static\n     */\n    public static function invalidStructureDefinition(string $structureDefinitionUrl, string $reason): static\n    {\n        $message = \"Invalid StructureDefinition '{$structureDefinitionUrl}': {$reason}\";\n\n        return new static($message, 400, null, [\n            'structure_definition_url' => $structureDefinitionUrl,\n            'reason'                   => $reason,\n        ]);\n    }\n\n    /**\n     * Create exception for missing content reference scenarios\n     *\n     * @param string $contentReference The missing content reference\n     * @param string $elementPath      The element path where the reference was expected\n     *\n     * @return static\n     */\n    public static function missingContentReference(string $contentReference, string $elementPath): static\n    {\n        $message = \"Missing content reference '{$contentReference}' for element '{$elementPath}'\";\n\n        return new static($message, 404, null, [\n            'content_reference' => $contentReference,\n            'element_path'      => $elementPath,\n        ]);\n    }\n\n    /**\n     * Create exception for unsupported FHIR version scenarios\n     *\n     * @param string $fhirVersion The unsupported FHIR version\n     *\n     * @return static\n     */\n    public static function unsupportedFhirVersion(string $fhirVersion): static\n    {\n        $message = \"Unsupported FHIR version '{$fhirVersion}'\";\n\n        return new static($message, 400, null, [\n            'fhir_version' => $fhirVersion,\n        ]);\n    }\n\n    /**\n     * Create exception for invalid element path scenarios\n     *\n     * @param string $elementPath The invalid element path\n     *\n     * @return static\n     */\n    public static function invalidElementPath(string $elementPath): static\n    {\n        $message = \"Invalid element path '{$elementPath}'\";\n\n        return new static($message, 400, null, [\n            'element_path' => $elementPath,\n        ]);\n    }\n}\n",
        "/fhir/src/Exception/PackageException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\n/**\n * Exception thrown when package-related operations fail\n *\n * This exception is thrown when FHIR package operations encounter errors,\n * such as package not found, download failures, or invalid package formats.\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nclass PackageException extends FHIRToolsException\n{\n    /**\n     * Create exception for package not found scenarios\n     *\n     * @param string $packageName The name of the package that was not found\n     * @param string $version     The version that was requested\n     *\n     * @return static\n     */\n    public static function packageNotFound(string $packageName, string $version = 'latest'): static\n    {\n        $message = \"Package '{$packageName}' version '{$version}' not found\";\n\n        return new static($message, 404, null, [\n            'package_name' => $packageName,\n            'version'      => $version,\n            'error_type'   => 'package_not_found',\n        ]);\n    }\n\n    /**\n     * Create exception for package download failures\n     *\n     * @param string $packageName The name of the package that failed to download\n     * @param string $version     The version that was requested\n     * @param int    $httpStatus  The HTTP status code from the failed request\n     *\n     * @return static\n     */\n    public static function downloadFailed(string $packageName, string $version, int $httpStatus): static\n    {\n        $message = \"Failed to download package '{$packageName}' version '{$version}' (HTTP {$httpStatus})\";\n\n        return new static($message, $httpStatus, null, [\n            'package_name' => $packageName,\n            'version'      => $version,\n            'http_status'  => $httpStatus,\n        ]);\n    }\n}\n",
        "/fhir/bootstrap.php": "<?php\n\ndeclare(strict_types=1);\n\n/**\n * Minimal PSR-4 autoloader for php-wasm virtual filesystem.\n * Maps component namespaces to their VFS paths.\n */\nspl_autoload_register(function (string $class): void {\n    $prefixes = [\n        'Ardenexal\\\\FHIRTools\\\\Component\\\\FHIRPath\\\\' => '/fhir/Component/FHIRPath/src/',\n        'Ardenexal\\\\FHIRTools\\\\Component\\\\Serialization\\\\' => '/fhir/Component/Serialization/src/',\n        'Ardenexal\\\\FHIRTools\\\\' => '/fhir/src/',\n    ];\n\n    foreach ($prefixes as $prefix => $baseDir) {\n        $len = strlen($prefix);\n        if (strncmp($class, $prefix, $len) !== 0) {\n            continue;\n        }\n\n        $relativeClass = substr($class, $len);\n        $file = $baseDir . str_replace('\\\\', '/', $relativeClass) . '.php';\n\n        if (file_exists($file)) {\n            require $file;\n            return;\n        }\n    }\n});"
    }
}