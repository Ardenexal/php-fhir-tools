{
    "component": "Serialization",
    "fileCount": 20,
    "files": {
        "/fhir/Component/Serialization/src/Context/FHIRSerializationContext.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Context;\n\n/**\n * Configuration context for FHIR serialization operations.\n *\n * This class provides configuration options for customizing FHIR serialization\n * behavior including format selection, validation modes, unknown element policies,\n * performance optimizations, and debugging support.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRSerializationContext\n{\n    public const FORMAT_JSON = 'json';\n\n    public const FORMAT_XML = 'xml';\n\n    public const VALIDATION_STRICT = 'strict';\n\n    public const VALIDATION_LENIENT = 'lenient';\n\n    public const UNKNOWN_POLICY_IGNORE = 'ignore';\n\n    public const UNKNOWN_POLICY_ERROR = 'error';\n\n    public const UNKNOWN_POLICY_PRESERVE = 'preserve';\n\n    /**\n     * @param string               $format                     Serialization format (json or xml)\n     * @param string               $validationMode             Validation mode (strict or lenient)\n     * @param string               $unknownElementPolicy       Policy for handling unknown elements\n     * @param bool                 $includeExtensions          Whether to include FHIR extensions\n     * @param bool                 $includeMetadata            Whether to include metadata elements\n     * @param bool                 $skipNonEssentialValidation Whether to skip non-essential validation for performance\n     * @param bool                 $enableDebugInfo            Whether to provide detailed debug information\n     * @param bool                 $validateReferences         Whether to validate FHIR references\n     * @param bool                 $omitNullValues             Whether to omit null values from output\n     * @param bool                 $omitEmptyArrays            Whether to omit empty arrays from output\n     * @param bool                 $enableXmlNamespaces        Whether to include XML namespaces (XML format only)\n     * @param bool                 $enableXmlSchemaValidation  Whether to validate against XML schemas (XML format only)\n     * @param array<string, mixed> $customOptions              Additional custom configuration options\n     */\n    public function __construct(\n        public readonly string $format = self::FORMAT_JSON,\n        public readonly string $validationMode = self::VALIDATION_LENIENT,\n        public readonly string $unknownElementPolicy = self::UNKNOWN_POLICY_IGNORE,\n        public readonly bool $includeExtensions = true,\n        public readonly bool $includeMetadata = true,\n        public readonly bool $skipNonEssentialValidation = false,\n        public readonly bool $enableDebugInfo = false,\n        public readonly bool $validateReferences = false,\n        public readonly bool $omitNullValues = true,\n        public readonly bool $omitEmptyArrays = true,\n        public readonly bool $enableXmlNamespaces = true,\n        public readonly bool $enableXmlSchemaValidation = false,\n        public readonly array $customOptions = []\n    ) {\n        $this->validateConfiguration();\n    }\n\n    /**\n     * Create a context for JSON serialization with default settings.\n     */\n    public static function forJson(): self\n    {\n        return new self(format: self::FORMAT_JSON);\n    }\n\n    /**\n     * Create a context for XML serialization with default settings.\n     */\n    public static function forXml(): self\n    {\n        return new self(\n            format: self::FORMAT_XML,\n            enableXmlNamespaces: true,\n        );\n    }\n\n    /**\n     * Create a context with strict validation enabled.\n     */\n    public static function withStrictValidation(): self\n    {\n        return new self(\n            validationMode: self::VALIDATION_STRICT,\n            validateReferences: true,\n            skipNonEssentialValidation: false,\n        );\n    }\n\n    /**\n     * Create a context with lenient validation for performance.\n     */\n    public static function withLenientValidation(): self\n    {\n        return new self(\n            validationMode: self::VALIDATION_LENIENT,\n            validateReferences: false,\n            skipNonEssentialValidation: true,\n        );\n    }\n\n    /**\n     * Create a context with debugging enabled.\n     */\n    public static function withDebugging(): self\n    {\n        return new self(enableDebugInfo: true);\n    }\n\n    /**\n     * Create a context that preserves unknown elements.\n     */\n    public static function preservingUnknownElements(): self\n    {\n        return new self(unknownElementPolicy: self::UNKNOWN_POLICY_PRESERVE);\n    }\n\n    /**\n     * Create a context that errors on unknown elements.\n     */\n    public static function erroringOnUnknownElements(): self\n    {\n        return new self(unknownElementPolicy: self::UNKNOWN_POLICY_ERROR);\n    }\n\n    /**\n     * Create a new context with modified format.\n     */\n    public function withFormat(string $format): self\n    {\n        return new self(\n            format: $format,\n            validationMode: $this->validationMode,\n            unknownElementPolicy: $this->unknownElementPolicy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $this->skipNonEssentialValidation,\n            enableDebugInfo: $this->enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: $this->customOptions,\n        );\n    }\n\n    /**\n     * Create a new context with modified validation mode.\n     */\n    public function withValidationMode(string $validationMode): self\n    {\n        return new self(\n            format: $this->format,\n            validationMode: $validationMode,\n            unknownElementPolicy: $this->unknownElementPolicy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $this->skipNonEssentialValidation,\n            enableDebugInfo: $this->enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: $this->customOptions,\n        );\n    }\n\n    /**\n     * Create a new context with modified unknown element policy.\n     */\n    public function withUnknownElementPolicy(string $policy): self\n    {\n        return new self(\n            format: $this->format,\n            validationMode: $this->validationMode,\n            unknownElementPolicy: $policy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $this->skipNonEssentialValidation,\n            enableDebugInfo: $this->enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: $this->customOptions,\n        );\n    }\n\n    /**\n     * Create a new context with debugging enabled/disabled.\n     */\n    public function withDebugInfo(bool $enableDebugInfo): self\n    {\n        return new self(\n            format: $this->format,\n            validationMode: $this->validationMode,\n            unknownElementPolicy: $this->unknownElementPolicy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $this->skipNonEssentialValidation,\n            enableDebugInfo: $enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: $this->customOptions,\n        );\n    }\n\n    /**\n     * Create a new context with performance optimization enabled/disabled.\n     */\n    public function withPerformanceOptimization(bool $skipNonEssentialValidation): self\n    {\n        return new self(\n            format: $this->format,\n            validationMode: $this->validationMode,\n            unknownElementPolicy: $this->unknownElementPolicy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $skipNonEssentialValidation,\n            enableDebugInfo: $this->enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: $this->customOptions,\n        );\n    }\n\n    /**\n     * Create a new context with additional custom options.\n     *\n     * @param array<string, mixed> $customOptions\n     */\n    public function withCustomOptions(array $customOptions): self\n    {\n        return new self(\n            format: $this->format,\n            validationMode: $this->validationMode,\n            unknownElementPolicy: $this->unknownElementPolicy,\n            includeExtensions: $this->includeExtensions,\n            includeMetadata: $this->includeMetadata,\n            skipNonEssentialValidation: $this->skipNonEssentialValidation,\n            enableDebugInfo: $this->enableDebugInfo,\n            validateReferences: $this->validateReferences,\n            omitNullValues: $this->omitNullValues,\n            omitEmptyArrays: $this->omitEmptyArrays,\n            enableXmlNamespaces: $this->enableXmlNamespaces,\n            enableXmlSchemaValidation: $this->enableXmlSchemaValidation,\n            customOptions: array_merge($this->customOptions, $customOptions),\n        );\n    }\n\n    /**\n     * Check if the current format is JSON.\n     */\n    public function isJsonFormat(): bool\n    {\n        return $this->format === self::FORMAT_JSON;\n    }\n\n    /**\n     * Check if the current format is XML.\n     */\n    public function isXmlFormat(): bool\n    {\n        return $this->format === self::FORMAT_XML;\n    }\n\n    /**\n     * Check if strict validation is enabled.\n     */\n    public function isStrictValidation(): bool\n    {\n        return $this->validationMode === self::VALIDATION_STRICT;\n    }\n\n    /**\n     * Check if lenient validation is enabled.\n     */\n    public function isLenientValidation(): bool\n    {\n        return $this->validationMode === self::VALIDATION_LENIENT;\n    }\n\n    /**\n     * Check if unknown elements should be ignored.\n     */\n    public function shouldIgnoreUnknownElements(): bool\n    {\n        return $this->unknownElementPolicy === self::UNKNOWN_POLICY_IGNORE;\n    }\n\n    /**\n     * Check if unknown elements should cause errors.\n     */\n    public function shouldErrorOnUnknownElements(): bool\n    {\n        return $this->unknownElementPolicy === self::UNKNOWN_POLICY_ERROR;\n    }\n\n    /**\n     * Check if unknown elements should be preserved.\n     */\n    public function shouldPreserveUnknownElements(): bool\n    {\n        return $this->unknownElementPolicy === self::UNKNOWN_POLICY_PRESERVE;\n    }\n\n    /**\n     * Get a custom option value.\n     */\n    public function getCustomOption(string $key, mixed $default = null): mixed\n    {\n        return $this->customOptions[$key] ?? $default;\n    }\n\n    /**\n     * Convert the context to an array suitable for Symfony Serializer context.\n     *\n     * @return array<string, mixed>\n     */\n    public function toSymfonyContext(): array\n    {\n        return [\n            'fhir_format'                        => $this->format,\n            'fhir_validation_mode'               => $this->validationMode,\n            'fhir_unknown_element_policy'        => $this->unknownElementPolicy,\n            'fhir_include_extensions'            => $this->includeExtensions,\n            'fhir_include_metadata'              => $this->includeMetadata,\n            'fhir_skip_non_essential_validation' => $this->skipNonEssentialValidation,\n            'fhir_enable_debug_info'             => $this->enableDebugInfo,\n            'fhir_validate_references'           => $this->validateReferences,\n            'fhir_omit_null_values'              => $this->omitNullValues,\n            'fhir_omit_empty_arrays'             => $this->omitEmptyArrays,\n            'fhir_enable_xml_namespaces'         => $this->enableXmlNamespaces,\n            'fhir_enable_xml_schema_validation'  => $this->enableXmlSchemaValidation,\n            'fhir_custom_options'                => $this->customOptions,\n            // Legacy context keys for backward compatibility\n            'unknown_property_policy' => $this->unknownElementPolicy,\n        ];\n    }\n\n    /**\n     * Create a context from Symfony Serializer context array.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function fromSymfonyContext(array $context): self\n    {\n        return new self(\n            format: $context['fhir_format']                                            ?? self::FORMAT_JSON,\n            validationMode: $context['fhir_validation_mode']                           ?? self::VALIDATION_STRICT,\n            unknownElementPolicy: $context['fhir_unknown_element_policy']              ?? $context['unknown_property_policy'] ?? self::UNKNOWN_POLICY_IGNORE,\n            includeExtensions: $context['fhir_include_extensions']                     ?? true,\n            includeMetadata: $context['fhir_include_metadata']                         ?? true,\n            skipNonEssentialValidation: $context['fhir_skip_non_essential_validation'] ?? false,\n            enableDebugInfo: $context['fhir_enable_debug_info']                        ?? false,\n            validateReferences: $context['fhir_validate_references']                   ?? false,\n            omitNullValues: $context['fhir_omit_null_values']                          ?? true,\n            omitEmptyArrays: $context['fhir_omit_empty_arrays']                        ?? true,\n            enableXmlNamespaces: $context['fhir_enable_xml_namespaces']                ?? true,\n            enableXmlSchemaValidation: $context['fhir_enable_xml_schema_validation']   ?? false,\n            customOptions: $context['fhir_custom_options']                             ?? [],\n        );\n    }\n\n    /**\n     * Validate the configuration values.\n     *\n     * @throws \\InvalidArgumentException If configuration is invalid\n     */\n    private function validateConfiguration(): void\n    {\n        $validFormats = [self::FORMAT_JSON, self::FORMAT_XML];\n        if (!in_array($this->format, $validFormats, true)) {\n            throw new \\InvalidArgumentException(sprintf('Invalid format \"%s\". Valid formats are: %s', $this->format, implode(', ', $validFormats)));\n        }\n\n        $validValidationModes = [self::VALIDATION_STRICT, self::VALIDATION_LENIENT];\n        if (!in_array($this->validationMode, $validValidationModes, true)) {\n            throw new \\InvalidArgumentException(sprintf('Invalid validation mode \"%s\". Valid modes are: %s', $this->validationMode, implode(', ', $validValidationModes)));\n        }\n\n        $validUnknownPolicies = [self::UNKNOWN_POLICY_IGNORE, self::UNKNOWN_POLICY_ERROR, self::UNKNOWN_POLICY_PRESERVE];\n        if (!in_array($this->unknownElementPolicy, $validUnknownPolicies, true)) {\n            throw new \\InvalidArgumentException(sprintf('Invalid unknown element policy \"%s\". Valid policies are: %s', $this->unknownElementPolicy, implode(', ', $validUnknownPolicies)));\n        }\n    }\n}\n",
        "/fhir/Component/Serialization/src/Context/FHIRSerializationContextFactory.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Context;\n\n/**\n * Factory for creating FHIR serialization contexts with appropriate defaults.\n *\n * This factory provides convenient methods for creating serialization contexts\n * with FHIR-specific defaults and validation rules.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRSerializationContextFactory\n{\n    /**\n     * Create a default FHIR serialization context for JSON format.\n     *\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createJsonContext(array $overrides = []): array\n    {\n        $defaults = [\n            'format'                      => 'json',\n            'skip_null_values'            => true,\n            'preserve_empty_objects'      => false,\n            'enable_max_depth'            => true,\n            'max_depth'                   => 10,\n            'fhir_strict_validation'      => true,\n            'fhir_include_extensions'     => true,\n            'fhir_include_metadata'       => true,\n            'fhir_unknown_element_policy' => 'ignore',\n            'fhir_validate_references'    => false,\n        ];\n\n        return array_merge($defaults, $overrides);\n    }\n\n    /**\n     * Create a default FHIR serialization context for XML format.\n     *\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createXmlContext(array $overrides = []): array\n    {\n        $defaults = [\n            'format'                      => 'xml',\n            'skip_null_values'            => true,\n            'preserve_empty_objects'      => false,\n            'enable_max_depth'            => true,\n            'max_depth'                   => 10,\n            'fhir_strict_validation'      => true,\n            'fhir_include_extensions'     => true,\n            'fhir_include_metadata'       => true,\n            'fhir_unknown_element_policy' => 'ignore',\n            'fhir_validate_references'    => false,\n            'fhir_xml_namespace'          => 'http://hl7.org/fhir',\n            'fhir_xml_schema_validation'  => false,\n        ];\n\n        return array_merge($defaults, $overrides);\n    }\n\n    /**\n     * Create a lenient FHIR serialization context for development/testing.\n     *\n     * @param string               $format    The serialization format ('json' or 'xml')\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createLenientContext(string $format = 'json', array $overrides = []): array\n    {\n        $baseContext = $format === 'xml' ? $this->createXmlContext() : $this->createJsonContext();\n\n        $lenientOverrides = [\n            'fhir_strict_validation'      => false,\n            'fhir_unknown_element_policy' => 'preserve',\n            'fhir_validate_references'    => false,\n        ];\n\n        return array_merge($baseContext, $lenientOverrides, $overrides);\n    }\n\n    /**\n     * Create a strict FHIR serialization context for production use.\n     *\n     * @param string               $format    The serialization format ('json' or 'xml')\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createStrictContext(string $format = 'json', array $overrides = []): array\n    {\n        $baseContext = $format === 'xml' ? $this->createXmlContext() : $this->createJsonContext();\n\n        $strictOverrides = [\n            'fhir_strict_validation'      => true,\n            'fhir_unknown_element_policy' => 'error',\n            'fhir_validate_references'    => true,\n        ];\n\n        return array_merge($baseContext, $strictOverrides, $overrides);\n    }\n\n    /**\n     * Create a context optimized for performance (minimal validation).\n     *\n     * @param string               $format    The serialization format ('json' or 'xml')\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createPerformanceContext(string $format = 'json', array $overrides = []): array\n    {\n        $baseContext = $format === 'xml' ? $this->createXmlContext() : $this->createJsonContext();\n\n        $performanceOverrides = [\n            'fhir_strict_validation'      => false,\n            'fhir_include_metadata'       => false,\n            'fhir_validate_references'    => false,\n            'fhir_unknown_element_policy' => 'ignore',\n            'enable_max_depth'            => false,\n        ];\n\n        return array_merge($baseContext, $performanceOverrides, $overrides);\n    }\n\n    /**\n     * Create a context for debugging with detailed information.\n     *\n     * @param string               $format    The serialization format ('json' or 'xml')\n     * @param array<string, mixed> $overrides Additional context options to override defaults\n     *\n     * @return array<string, mixed>\n     */\n    public function createDebugContext(string $format = 'json', array $overrides = []): array\n    {\n        $baseContext = $format === 'xml' ? $this->createXmlContext() : $this->createJsonContext();\n\n        $debugOverrides = [\n            'fhir_debug_mode'          => true,\n            'fhir_include_debug_info'  => true,\n            'fhir_trace_serialization' => true,\n        ];\n\n        return array_merge($baseContext, $debugOverrides, $overrides);\n    }\n}\n",
        "/fhir/Component/Serialization/src/Context/FHIRSerializationDebugInfo.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Context;\n\n/**\n * Debug information container for FHIR serialization operations.\n *\n * This class provides detailed context and debugging information\n * for FHIR serialization and deserialization operations.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRSerializationDebugInfo\n{\n    /**\n     * @param string               $operation      The serialization operation (normalize/denormalize)\n     * @param string               $format         The format being processed (json/xml)\n     * @param string|null          $elementPath    The current element path being processed\n     * @param string|null          $objectType     The type of object being processed\n     * @param string|null          $normalizerType The type of normalizer being used\n     * @param array<string, mixed> $context        The serialization context\n     * @param array<string, mixed> $metadata       Additional metadata about the operation\n     * @param array<string>        $warnings       Non-fatal warnings encountered\n     * @param float|null           $startTime      Operation start time (microtime)\n     * @param float|null           $endTime        Operation end time (microtime)\n     */\n    public function __construct(\n        public readonly string $operation,\n        public readonly string $format,\n        public readonly ?string $elementPath = null,\n        public readonly ?string $objectType = null,\n        public readonly ?string $normalizerType = null,\n        public readonly array $context = [],\n        public readonly array $metadata = [],\n        public readonly array $warnings = [],\n        public readonly ?float $startTime = null,\n        public readonly ?float $endTime = null\n    ) {\n    }\n\n    /**\n     * Create debug info for a normalization operation.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function forNormalization(\n        string $format,\n        ?string $elementPath = null,\n        ?string $objectType = null,\n        ?string $normalizerType = null,\n        array $context = []\n    ): self {\n        return new self(\n            operation: 'normalize',\n            format: $format,\n            elementPath: $elementPath,\n            objectType: $objectType,\n            normalizerType: $normalizerType,\n            context: $context,\n            startTime: microtime(true),\n        );\n    }\n\n    /**\n     * Create debug info for a denormalization operation.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function forDenormalization(\n        string $format,\n        ?string $elementPath = null,\n        ?string $objectType = null,\n        ?string $normalizerType = null,\n        array $context = []\n    ): self {\n        return new self(\n            operation: 'denormalize',\n            format: $format,\n            elementPath: $elementPath,\n            objectType: $objectType,\n            normalizerType: $normalizerType,\n            context: $context,\n            startTime: microtime(true),\n        );\n    }\n\n    /**\n     * Add a warning to the debug info.\n     */\n    public function withWarning(string $warning): self\n    {\n        return new self(\n            operation: $this->operation,\n            format: $this->format,\n            elementPath: $this->elementPath,\n            objectType: $this->objectType,\n            normalizerType: $this->normalizerType,\n            context: $this->context,\n            metadata: $this->metadata,\n            warnings: array_merge($this->warnings, [$warning]),\n            startTime: $this->startTime,\n            endTime: $this->endTime,\n        );\n    }\n\n    /**\n     * Add metadata to the debug info.\n     *\n     * @param array<string, mixed> $metadata\n     */\n    public function withMetadata(array $metadata): self\n    {\n        return new self(\n            operation: $this->operation,\n            format: $this->format,\n            elementPath: $this->elementPath,\n            objectType: $this->objectType,\n            normalizerType: $this->normalizerType,\n            context: $this->context,\n            metadata: array_merge($this->metadata, $metadata),\n            warnings: $this->warnings,\n            startTime: $this->startTime,\n            endTime: $this->endTime,\n        );\n    }\n\n    /**\n     * Mark the operation as completed.\n     */\n    public function completed(): self\n    {\n        return new self(\n            operation: $this->operation,\n            format: $this->format,\n            elementPath: $this->elementPath,\n            objectType: $this->objectType,\n            normalizerType: $this->normalizerType,\n            context: $this->context,\n            metadata: $this->metadata,\n            warnings: $this->warnings,\n            startTime: $this->startTime,\n            endTime: microtime(true),\n        );\n    }\n\n    /**\n     * Get the operation duration in milliseconds.\n     */\n    public function getDurationMs(): ?float\n    {\n        if ($this->startTime === null || $this->endTime === null) {\n            return null;\n        }\n\n        return ($this->endTime - $this->startTime) * 1000;\n    }\n\n    /**\n     * Check if the operation has warnings.\n     */\n    public function hasWarnings(): bool\n    {\n        return !empty($this->warnings);\n    }\n\n    /**\n     * Get the number of warnings.\n     */\n    public function getWarningCount(): int\n    {\n        return count($this->warnings);\n    }\n\n    /**\n     * Convert to array for logging or debugging.\n     *\n     * @return array<string, mixed>\n     */\n    public function toArray(): array\n    {\n        return [\n            'operation'       => $this->operation,\n            'format'          => $this->format,\n            'element_path'    => $this->elementPath,\n            'object_type'     => $this->objectType,\n            'normalizer_type' => $this->normalizerType,\n            'context'         => $this->context,\n            'metadata'        => $this->metadata,\n            'warnings'        => $this->warnings,\n            'start_time'      => $this->startTime,\n            'end_time'        => $this->endTime,\n            'duration_ms'     => $this->getDurationMs(),\n            'warning_count'   => $this->getWarningCount(),\n        ];\n    }\n\n    /**\n     * Convert to JSON string for logging.\n     */\n    public function toJson(): string\n    {\n        return json_encode($this->toArray(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT);\n    }\n\n    /**\n     * Create a summary string for quick debugging.\n     */\n    public function getSummary(): string\n    {\n        $parts = [\n            $this->operation,\n            $this->format,\n        ];\n\n        if ($this->objectType !== null) {\n            $parts[] = $this->objectType;\n        }\n\n        if ($this->elementPath !== null) {\n            $parts[] = \"path:{$this->elementPath}\";\n        }\n\n        if ($this->getDurationMs() !== null) {\n            $parts[] = sprintf('%.2fms', $this->getDurationMs());\n        }\n\n        if ($this->hasWarnings()) {\n            $parts[] = sprintf('%d warnings', $this->getWarningCount());\n        }\n\n        return implode(' | ', $parts);\n    }\n\n    /**\n     * Get the debug information as an array.\n     *\n     * @return array<string, mixed>\n     */\n    public function getDebugInfo(): array\n    {\n        return $this->toArray();\n    }\n}\n",
        "/fhir/Component/Serialization/src/Exception/FHIRSerializationException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Exception;\n\nuse Ardenexal\\FHIRTools\\Exception\\FHIRToolsException;\nuse Ardenexal\\FHIRTools\\Serialization\\FHIRSerializationDebugInfo;\n\n/**\n * Base exception for FHIR serialization errors.\n *\n * This exception is thrown when errors occur during FHIR serialization\n * or deserialization operations.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRSerializationException extends FHIRToolsException\n{\n    /**\n     * @param string                          $message     The exception message\n     * @param int                             $code        The exception code\n     * @param \\Exception|null                 $previous    The previous exception\n     * @param string|null                     $elementPath The element path where the error occurred\n     * @param array<string, mixed>            $context     Additional context information\n     * @param FHIRSerializationDebugInfo|null $debugInfo   Debug information\n     */\n    public function __construct(\n        string $message = '',\n        int $code = 0,\n        ?\\Exception $previous = null,\n        public readonly ?string $elementPath = null,\n        array $context = [],\n        public readonly ?FHIRSerializationDebugInfo $debugInfo = null\n    ) {\n        parent::__construct($message, $code, $previous, $context);\n    }\n\n    /**\n     * Create an exception for configuration errors.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function configurationError(string $message, array $context = []): self\n    {\n        return new self(\n            message: \"Configuration error: {$message}\",\n            context: $context,\n        );\n    }\n\n    /**\n     * Create an exception for format errors.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function formatError(string $format, string $message, array $context = []): self\n    {\n        return new self(\n            message: \"Format error ({$format}): {$message}\",\n            context: array_merge($context, ['format' => $format]),\n        );\n    }\n\n    /**\n     * Create an exception for validation errors.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function validationError(string $message, ?string $elementPath = null, array $context = []): self\n    {\n        return new self(\n            message: \"Validation error: {$message}\",\n            elementPath: $elementPath,\n            context: $context,\n        );\n    }\n\n    /**\n     * Create an exception for unknown element policy violations.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function unknownElementError(string $elementName, string $policy, ?string $elementPath = null, array $context = []): self\n    {\n        return new self(\n            message: \"Unknown element '{$elementName}' encountered with policy '{$policy}'\",\n            elementPath: $elementPath,\n            context: array_merge($context, ['element_name' => $elementName, 'policy' => $policy]),\n        );\n    }\n\n    /**\n     * Create an exception for performance optimization errors.\n     *\n     * @param array<string, mixed> $context\n     */\n    public static function performanceError(string $message, array $context = []): self\n    {\n        return new self(\n            message: \"Performance optimization error: {$message}\",\n            context: $context,\n        );\n    }\n\n    /**\n     * Get the element path where the error occurred.\n     */\n    public function getElementPath(): ?string\n    {\n        return $this->elementPath;\n    }\n\n    /**\n     * Get debug information if available.\n     */\n    public function getDebugInfo(): ?FHIRSerializationDebugInfo\n    {\n        return $this->debugInfo;\n    }\n\n    /**\n     * Check if debug information is available.\n     */\n    public function hasDebugInfo(): bool\n    {\n        return $this->debugInfo !== null;\n    }\n\n    /**\n     * Get a detailed error message including context and debug info.\n     */\n    public function getDetailedMessage(): string\n    {\n        $message = $this->getMessage();\n\n        if ($this->elementPath !== null) {\n            $message .= \" (at path: {$this->elementPath})\";\n        }\n\n        if (!empty($this->context)) {\n            $contextStr = json_encode($this->context, JSON_THROW_ON_ERROR);\n            $message .= \" (context: {$contextStr})\";\n        }\n\n        if ($this->debugInfo !== null) {\n            $message .= \" (debug: {$this->debugInfo->getSummary()})\";\n        }\n\n        return $message;\n    }\n}\n",
        "/fhir/Component/Serialization/src/Exception/ValidationException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Exception;\n\nuse Ardenexal\\FHIRTools\\Exception\\FHIRToolsException;\n\n/**\n * Exception thrown when validation fails\n *\n * This exception is used for all validation-related errors including:\n * - Invalid resource types that don't match expected values\n * - Missing required fields in FHIR structures\n * - Invalid field values that don't match expected types\n * - Multiple validation errors collected during processing\n *\n * Each static factory method provides specific context information\n * to help identify the exact validation failure and its location.\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nclass ValidationException extends FHIRToolsException\n{\n    /**\n     * Create exception for invalid resource type\n     *\n     * This method creates an exception when a resource has an unexpected type\n     * that doesn't match what was expected during validation.\n     *\n     * @param string $resourceType The actual resource type found\n     * @param string $expectedType The expected resource type\n     *\n     * @return self The configured exception instance\n     */\n    public static function invalidResourceType(string $resourceType, string $expectedType): self\n    {\n        return new self(\n            \"Invalid resource type '{$resourceType}', expected '{$expectedType}'\",\n            400,\n            null,\n            [\n                'resource_type' => $resourceType,\n                'expected_type' => $expectedType,\n                'error_type'    => 'invalid_resource_type',\n            ],\n        );\n    }\n\n    /**\n     * Create exception for missing required field\n     *\n     * This method creates an exception when a required field is missing\n     * from a FHIR structure during validation.\n     *\n     * @param string $fieldName   The name of the missing required field\n     * @param string $elementPath The path of the element missing the field\n     *\n     * @return self The configured exception instance\n     */\n    public static function missingRequiredField(string $fieldName, string $elementPath): self\n    {\n        return new self(\n            \"Missing required field '{$fieldName}' in element '{$elementPath}'\",\n            400,\n            null,\n            [\n                'field_name'   => $fieldName,\n                'element_path' => $elementPath,\n                'error_type'   => 'missing_required_field',\n            ],\n        );\n    }\n\n    /**\n     * Create exception for invalid field value\n     *\n     * This method creates an exception when a field has a value that doesn't\n     * match the expected type during validation.\n     *\n     * @param string $fieldName    The name of the field with invalid value\n     * @param mixed  $value        The actual value that was invalid\n     * @param string $expectedType The expected type for the field\n     *\n     * @return self The configured exception instance\n     */\n    public static function invalidFieldValue(string $fieldName, mixed $value, string $expectedType): self\n    {\n        return new self(\n            \"Invalid value for field '{$fieldName}': expected {$expectedType}, got \" . gettype($value),\n            400,\n            null,\n            [\n                'field_name'    => $fieldName,\n                'actual_value'  => $value,\n                'actual_type'   => gettype($value),\n                'expected_type' => $expectedType,\n                'error_type'    => 'invalid_field_value',\n            ],\n        );\n    }\n\n    /**\n     * Create exception for multiple validation errors\n     *\n     * This method creates an exception when multiple validation errors\n     * have been collected and need to be reported together.\n     *\n     * @param array<mixed> $errors Array of validation errors\n     *\n     * @return self The configured exception instance\n     */\n    public static function multipleValidationErrors(array $errors): self\n    {\n        $errorCount = count($errors);\n\n        return new self(\n            \"Validation failed with {$errorCount} error(s)\",\n            400,\n            null,\n            [\n                'errors'      => $errors,\n                'error_count' => $errorCount,\n                'error_type'  => 'multiple_validation_errors',\n            ],\n        );\n    }\n}\n",
        "/fhir/Component/Serialization/src/FHIRTypeResolver.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization;\n\n/**\n * Comprehensive FHIR discriminator map resolver for polymorphic type resolution.\n *\n * This resolver handles type resolution for polymorphic FHIR elements using\n * discriminator maps and other type resolution strategies including:\n * - Resource type resolution based on resourceType field\n * - Choice element resolution (value[x] patterns)\n * - Reference type resolution for polymorphic references\n * - Extension value type resolution\n *\n * @author Kiro AI Assistant\n */\nclass FHIRTypeResolver implements FHIRTypeResolverInterface\n{\n    /** @var array<string, string> */\n    private array $resourceTypeMapping = [];\n\n    /** @var array<string, string> */\n    private array $choiceElementMapping = [];\n\n    /** @var array<string, string> */\n    private array $referenceTypeMapping = [];\n\n    /** @var array<string, string> */\n    private array $extensionValueMapping = [];\n\n    /** @var array<string, string> */\n    private array $complexTypeMapping = [];\n\n    /**\n     * @param array<string, string> $resourceTypeMapping\n     * @param array<string, string> $choiceElementMapping\n     * @param array<string, string> $referenceTypeMapping\n     * @param array<string, string> $extensionValueMapping\n     * @param array<string, string> $complexTypeMapping\n     */\n    public function __construct(\n        array $resourceTypeMapping = [],\n        array $choiceElementMapping = [],\n        array $referenceTypeMapping = [],\n        array $extensionValueMapping = [],\n        array $complexTypeMapping = []\n    ) {\n        $this->resourceTypeMapping   = $resourceTypeMapping;\n        $this->choiceElementMapping  = $choiceElementMapping;\n        $this->referenceTypeMapping  = $referenceTypeMapping;\n        $this->extensionValueMapping = $extensionValueMapping;\n        $this->complexTypeMapping    = $complexTypeMapping;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function resolveType(array $data, array $context = []): ?string\n    {\n        // Try to resolve as resource type first\n        if (isset($data['resourceType'])) {\n            return $this->resolveResourceType($data);\n        }\n\n        // Try to resolve as extension with polymorphic value\n        if (isset($data['url']) && $this->hasExtensionValue($data)) {\n            $type = $this->resolveExtensionValueType($data);\n            if ($type !== null) {\n                return $type;\n            }\n        }\n\n        // Try to resolve as choice element\n        foreach ($data as $key => $value) {\n            if (str_starts_with($key, 'value') && $key !== 'value') {\n                $type = $this->resolveChoiceElementType('value', $data);\n                if ($type !== null) {\n                    return $type;\n                }\n            }\n        }\n\n        // Try to resolve as reference\n        if (isset($data['reference']) || isset($data['type'])) {\n            return $this->resolveReferenceType($data);\n        }\n\n        // Try to resolve as complex type using context or data structure\n        return $this->resolveComplexType($data, $context);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getDiscriminatorProperty(): string\n    {\n        return 'resourceType';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getTypeMapping(): array\n    {\n        return $this->resourceTypeMapping;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function resolveResourceType(array $data): ?string\n    {\n        if (!isset($data['resourceType'])) {\n            return null;\n        }\n\n        $resourceType = $data['resourceType'];\n        if (!is_string($resourceType)) {\n            return null;\n        }\n\n        // Return the mapped class name if available, otherwise construct a default one\n        if (isset($this->resourceTypeMapping[$resourceType])) {\n            return $this->resourceTypeMapping[$resourceType];\n        }\n\n        // Default mapping: assume classes are named FHIR{ResourceType}\n        return 'FHIR' . $resourceType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function resolveChoiceElementType(string $propertyName, array $data): ?string\n    {\n        // Look for properties that start with the property name followed by a type\n        foreach ($data as $key => $value) {\n            if (str_starts_with($key, $propertyName) && $key !== $propertyName) {\n                $typeSuffix = substr($key, strlen($propertyName));\n\n                // Check if we have a mapping for this choice element\n                $mappingKey = $propertyName . $typeSuffix;\n                if (isset($this->choiceElementMapping[$mappingKey])) {\n                    return $this->choiceElementMapping[$mappingKey];\n                }\n\n                // Default mapping: assume classes are named FHIR{Type}\n                return 'FHIR' . $typeSuffix;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function resolveReferenceType(array $referenceData): ?string\n    {\n        // Try to resolve from explicit type field\n        if (isset($referenceData['type'])) {\n            $type = $referenceData['type'];\n            if (is_string($type)) {\n                if (isset($this->referenceTypeMapping[$type])) {\n                    return $this->referenceTypeMapping[$type];\n                }\n\n                // Default mapping for explicit type field\n                return 'FHIR' . $type;\n            }\n        }\n\n        // Try to resolve from reference URL\n        if (isset($referenceData['reference'])) {\n            $reference = $referenceData['reference'];\n            if (is_string($reference)) {\n                // Extract resource type from reference like \"Patient/123\"\n                $parts = explode('/', $reference);\n                if (count($parts) >= 2) {\n                    $resourceType = $parts[0];\n                    if (isset($this->resourceTypeMapping[$resourceType])) {\n                        return $this->resourceTypeMapping[$resourceType];\n                    }\n\n                    return 'FHIR' . $resourceType;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Add a resource type mapping\n     */\n    public function addResourceTypeMapping(string $resourceType, string $className): void\n    {\n        $this->resourceTypeMapping[$resourceType] = $className;\n    }\n\n    /**\n     * Add a choice element mapping\n     */\n    public function addChoiceElementMapping(string $choiceElement, string $className): void\n    {\n        $this->choiceElementMapping[$choiceElement] = $className;\n    }\n\n    /**\n     * Add a reference type mapping\n     */\n    public function addReferenceTypeMapping(string $referenceType, string $className): void\n    {\n        $this->referenceTypeMapping[$referenceType] = $className;\n    }\n\n    /**\n     * Add an extension value type mapping\n     */\n    public function addExtensionValueMapping(string $valueType, string $className): void\n    {\n        $this->extensionValueMapping[$valueType] = $className;\n    }\n\n    /**\n     * Add a complex type mapping\n     */\n    public function addComplexTypeMapping(string $complexType, string $className): void\n    {\n        $this->complexTypeMapping[$complexType] = $className;\n    }\n\n    /**\n     * Get all resource type mappings\n     *\n     * @return array<string, string>\n     */\n    public function getResourceTypeMappings(): array\n    {\n        return $this->resourceTypeMapping;\n    }\n\n    /**\n     * Get all choice element mappings\n     *\n     * @return array<string, string>\n     */\n    public function getChoiceElementMappings(): array\n    {\n        return $this->choiceElementMapping;\n    }\n\n    /**\n     * Get all reference type mappings\n     *\n     * @return array<string, string>\n     */\n    public function getReferenceTypeMappings(): array\n    {\n        return $this->referenceTypeMapping;\n    }\n\n    /**\n     * Get all extension value mappings\n     *\n     * @return array<string, string>\n     */\n    public function getExtensionValueMappings(): array\n    {\n        return $this->extensionValueMapping;\n    }\n\n    /**\n     * Get all complex type mappings\n     *\n     * @return array<string, string>\n     */\n    public function getComplexTypeMappings(): array\n    {\n        return $this->complexTypeMapping;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function resolveComplexType(array $data, array $context = []): ?string\n    {\n        // If context provides a hint about the expected type, use it\n        if (isset($context['expected_type'])) {\n            return $context['expected_type'];\n        }\n\n        // Try to infer complex type from data structure patterns\n        if (isset($context['property_name'])) {\n            $propertyName = $context['property_name'];\n\n            // Check if we have a mapping for this property to a complex type\n            if (isset($this->complexTypeMapping[$propertyName])) {\n                return $this->complexTypeMapping[$propertyName];\n            }\n        }\n\n        // Try to infer from common FHIR complex type patterns\n        if (isset($data['system']) && isset($data['code'])) {\n            return $this->complexTypeMapping['Coding'] ?? 'FHIRCoding';\n        }\n\n        if (isset($data['family']) || isset($data['given'])) {\n            return $this->complexTypeMapping['HumanName'] ?? 'FHIRHumanName';\n        }\n\n        if (isset($data['line']) || isset($data['city']) || isset($data['postalCode'])) {\n            return $this->complexTypeMapping['Address'] ?? 'FHIRAddress';\n        }\n\n        if (isset($data['start']) || isset($data['end'])) {\n            return $this->complexTypeMapping['Period'] ?? 'FHIRPeriod';\n        }\n\n        if (isset($data['value']) && isset($data['unit'])) {\n            return $this->complexTypeMapping['Quantity'] ?? 'FHIRQuantity';\n        }\n\n        return null;\n    }\n\n    /**\n     * Resolves the type for FHIR extension values (polymorphic extensions).\n     *\n     * @param array<string, mixed> $extensionData The extension data containing value[x]\n     *\n     * @return string|null The resolved extension value type, or null if not found\n     */\n    public function resolveExtensionValueType(array $extensionData): ?string\n    {\n        // Look for value[x] patterns in extension data\n        foreach ($extensionData as $key => $value) {\n            if (str_starts_with($key, 'value') && $key !== 'value') {\n                $typeSuffix = substr($key, 5); // Remove 'value' prefix\n\n                // Check if we have a mapping for this extension value type\n                if (isset($this->extensionValueMapping[$typeSuffix])) {\n                    return $this->extensionValueMapping[$typeSuffix];\n                }\n\n                // Default mapping: assume classes are named FHIR{Type}\n                return 'FHIR' . $typeSuffix;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks if the given data contains an extension value field.\n     *\n     * @param array<string, mixed> $data The data to check\n     *\n     * @return bool True if extension value field is present\n     */\n    private function hasExtensionValue(array $data): bool\n    {\n        foreach ($data as $key => $value) {\n            if (str_starts_with($key, 'value') && $key !== 'value') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n",
        "/fhir/Component/Serialization/src/FHIRTypeResolverInterface.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization;\n\n/**\n * Interface for resolving FHIR types from serialized data using discriminator maps\n * and other type resolution strategies for polymorphic FHIR elements.\n *\n * @author Kiro AI Assistant\n */\ninterface FHIRTypeResolverInterface\n{\n    /**\n     * Resolves the concrete type from the given data and context.\n     *\n     * @param array<string, mixed> $data    The serialized data to analyze\n     * @param array<string, mixed> $context Additional context for type resolution\n     *\n     * @return string|null The resolved type class name, or null if type cannot be resolved\n     */\n    public function resolveType(array $data, array $context = []): ?string;\n\n    /**\n     * Gets the discriminator property name used for type resolution.\n     *\n     * @return string The property name that contains type information\n     */\n    public function getDiscriminatorProperty(): string;\n\n    /**\n     * Gets the mapping from discriminator values to concrete types.\n     *\n     * @return array<string, string> Mapping from discriminator value to class name\n     */\n    public function getTypeMapping(): array;\n\n    /**\n     * Resolves the FHIR resource type from resource data.\n     *\n     * @param array<string, mixed> $data The resource data containing resourceType\n     *\n     * @return string|null The resolved resource class name, or null if not resolvable\n     */\n    public function resolveResourceType(array $data): ?string;\n\n    /**\n     * Resolves the type for FHIR choice elements (value[x] patterns).\n     *\n     * @param string               $propertyName The base property name (e.g., \"value\")\n     * @param array<string, mixed> $data         The data containing the choice element\n     *\n     * @return string|null The resolved type for the choice element, or null if not found\n     */\n    public function resolveChoiceElementType(string $propertyName, array $data): ?string;\n\n    /**\n     * Resolves the target type for FHIR reference elements.\n     *\n     * @param array<string, mixed> $referenceData The reference data containing type information\n     *\n     * @return string|null The resolved reference target type, or null if not resolvable\n     */\n    public function resolveReferenceType(array $referenceData): ?string;\n\n    /**\n     * Resolves the concrete complex type from the given data and context.\n     *\n     * @param array<string, mixed> $data    The serialized complex type data to analyze\n     * @param array<string, mixed> $context Additional context for type resolution\n     *\n     * @return string|null The resolved complex type class name, or null if type cannot be resolved\n     */\n    public function resolveComplexType(array $data, array $context = []): ?string;\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRBackboneElementMetadata.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Metadata container for FHIR backbone element information.\n *\n * @author Kiro AI Assistant\n */\nreadonly class FHIRBackboneElementMetadata\n{\n    public function __construct(\n        public string $parentResource,\n        public string $elementPath,\n        public string $fhirVersion\n    ) {\n    }\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRComplexTypeMetadata.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Metadata container for FHIR complex type information.\n *\n * @author Kiro AI Assistant\n */\nreadonly class FHIRComplexTypeMetadata\n{\n    public function __construct(\n        public string $typeName,\n        public string $fhirVersion\n    ) {\n    }\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRMetadataCache.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Cache for FHIR metadata to improve performance by avoiding repeated reflection operations.\n *\n * This cache stores metadata extracted from FHIR classes to avoid the overhead\n * of reflection and attribute parsing on every serialization operation.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRMetadataCache\n{\n    /** @var array<string, FHIRResourceMetadata|null> */\n    private array $resourceTypeCache = [];\n\n    /** @var array<string, FHIRComplexTypeMetadata|null> */\n    private array $complexTypeCache = [];\n\n    /** @var array<string, FHIRPrimitiveTypeMetadata|null> */\n    private array $primitiveTypeCache = [];\n\n    /** @var array<string, FHIRBackboneElementMetadata|null> */\n    private array $backboneElementCache = [];\n\n    /** @var array<string, string|null> */\n    private array $fhirTypeCache = [];\n\n    /** @var array<string, string|null> */\n    private array $fhirVersionCache = [];\n\n    /** @var array<string, string|null> */\n    private array $structureTypeCache = [];\n\n    /**\n     * Get cached resource metadata for a class\n     */\n    public function getResourceMetadata(string $className): ?FHIRResourceMetadata\n    {\n        return $this->resourceTypeCache[$className] ?? null;\n    }\n\n    /**\n     * Cache resource metadata for a class\n     */\n    public function cacheResourceMetadata(string $className, ?FHIRResourceMetadata $metadata): void\n    {\n        $this->resourceTypeCache[$className] = $metadata;\n    }\n\n    /**\n     * Get cached complex type metadata for a class\n     */\n    public function getComplexTypeMetadata(string $className): ?FHIRComplexTypeMetadata\n    {\n        return $this->complexTypeCache[$className] ?? null;\n    }\n\n    /**\n     * Cache complex type metadata for a class\n     */\n    public function cacheComplexTypeMetadata(string $className, ?FHIRComplexTypeMetadata $metadata): void\n    {\n        $this->complexTypeCache[$className] = $metadata;\n    }\n\n    /**\n     * Get cached primitive type metadata for a class\n     */\n    public function getPrimitiveTypeMetadata(string $className): ?FHIRPrimitiveTypeMetadata\n    {\n        return $this->primitiveTypeCache[$className] ?? null;\n    }\n\n    /**\n     * Cache primitive type metadata for a class\n     */\n    public function cachePrimitiveTypeMetadata(string $className, ?FHIRPrimitiveTypeMetadata $metadata): void\n    {\n        $this->primitiveTypeCache[$className] = $metadata;\n    }\n\n    /**\n     * Get cached backbone element metadata for a class\n     */\n    public function getBackboneElementMetadata(string $className): ?FHIRBackboneElementMetadata\n    {\n        return $this->backboneElementCache[$className] ?? null;\n    }\n\n    /**\n     * Cache backbone element metadata for a class\n     */\n    public function cacheBackboneElementMetadata(string $className, ?FHIRBackboneElementMetadata $metadata): void\n    {\n        $this->backboneElementCache[$className] = $metadata;\n    }\n\n    /**\n     * Get cached FHIR type for a class\n     */\n    public function getFHIRTypeMetadata(string $className): ?string\n    {\n        if (!array_key_exists($className, $this->fhirTypeCache)) {\n            return null;\n        }\n\n        return $this->fhirTypeCache[$className];\n    }\n\n    /**\n     * Cache FHIR type for a class\n     */\n    public function cacheFHIRTypeMetadata(string $className, ?string $fhirType): void\n    {\n        $this->fhirTypeCache[$className] = $fhirType;\n    }\n\n    /**\n     * Get cached FHIR version for a class\n     */\n    public function getFHIRVersionMetadata(string $className): ?string\n    {\n        if (!array_key_exists($className, $this->fhirVersionCache)) {\n            return null;\n        }\n\n        return $this->fhirVersionCache[$className];\n    }\n\n    /**\n     * Cache FHIR version for a class\n     */\n    public function cacheFHIRVersionMetadata(string $className, ?string $fhirVersion): void\n    {\n        $this->fhirVersionCache[$className] = $fhirVersion;\n    }\n\n    /**\n     * Get cached structure type for a class\n     */\n    public function getStructureTypeMetadata(string $className): ?string\n    {\n        if (!array_key_exists($className, $this->structureTypeCache)) {\n            return null;\n        }\n\n        return $this->structureTypeCache[$className];\n    }\n\n    /**\n     * Cache structure type for a class\n     */\n    public function cacheStructureTypeMetadata(string $className, ?string $structureType): void\n    {\n        $this->structureTypeCache[$className] = $structureType;\n    }\n\n    /**\n     * Invalidate all cached metadata\n     */\n    public function invalidateCache(): void\n    {\n        $this->resourceTypeCache    = [];\n        $this->complexTypeCache     = [];\n        $this->primitiveTypeCache   = [];\n        $this->backboneElementCache = [];\n        $this->fhirTypeCache        = [];\n        $this->fhirVersionCache     = [];\n        $this->structureTypeCache   = [];\n    }\n\n    /**\n     * Invalidate cached metadata for a specific class\n     */\n    public function invalidateClass(string $className): void\n    {\n        unset(\n            $this->resourceTypeCache[$className],\n            $this->complexTypeCache[$className],\n            $this->primitiveTypeCache[$className],\n            $this->backboneElementCache[$className],\n            $this->fhirTypeCache[$className],\n            $this->fhirVersionCache[$className],\n            $this->structureTypeCache[$className],\n        );\n    }\n\n    /**\n     * Get cache statistics for monitoring and debugging\n     *\n     * @return array<string, int>\n     */\n    public function getCacheStats(): array\n    {\n        return [\n            'resource_entries'         => count($this->resourceTypeCache),\n            'complex_type_entries'     => count($this->complexTypeCache),\n            'primitive_type_entries'   => count($this->primitiveTypeCache),\n            'backbone_element_entries' => count($this->backboneElementCache),\n            'fhir_type_entries'        => count($this->fhirTypeCache),\n            'fhir_version_entries'     => count($this->fhirVersionCache),\n            'structure_type_entries'   => count($this->structureTypeCache),\n        ];\n    }\n\n    /**\n     * Check if the cache is empty\n     */\n    public function isEmpty(): bool\n    {\n        return empty($this->resourceTypeCache)\n               && empty($this->complexTypeCache)\n               && empty($this->primitiveTypeCache)\n               && empty($this->backboneElementCache)\n               && empty($this->fhirTypeCache)\n               && empty($this->fhirVersionCache)\n               && empty($this->structureTypeCache);\n    }\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRMetadataExtractor.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\nuse Ardenexal\\FHIRTools\\Component\\CodeGeneration\\Attributes\\FHIRBackboneElement;\nuse Ardenexal\\FHIRTools\\Component\\CodeGeneration\\Attributes\\FHIRComplexType;\nuse Ardenexal\\FHIRTools\\Component\\CodeGeneration\\Attributes\\FHIRPrimitive;\nuse Ardenexal\\FHIRTools\\Component\\CodeGeneration\\Attributes\\FhirResource;\n\n/**\n * Extracts FHIR metadata from PHP objects using attributes and reflection.\n *\n * This class provides methods to identify FHIR structure types and extract\n * relevant metadata for serialization purposes.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRMetadataExtractor implements FHIRMetadataExtractorInterface\n{\n    private FHIRMetadataCache $cache;\n\n    public function __construct(?FHIRMetadataCache $cache = null)\n    {\n        $this->cache = $cache ?? new FHIRMetadataCache();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function extractResourceType(object $object): ?string\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getResourceMetadata($className);\n        if ($cached !== null) {\n            return $cached->resourceType;\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n            $attributes = $reflection->getAttributes(FhirResource::class);\n\n            if (empty($attributes)) {\n                $this->cache->cacheResourceMetadata($className, null);\n\n                return null;\n            }\n\n            $attribute = $attributes[0]->newInstance();\n            $metadata  = new FHIRResourceMetadata(\n                $attribute->getResourceType(),\n                $attribute->fhirVersion,\n                $attribute->getProfile(),\n            );\n\n            $this->cache->cacheResourceMetadata($className, $metadata);\n\n            return $metadata->resourceType;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheResourceMetadata($className, null);\n\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function extractFHIRType(object $object): ?string\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getFHIRTypeMetadata($className);\n        if ($cached !== null) {\n            return $cached;\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n\n            // Check for resource type\n            $resourceAttributes = $reflection->getAttributes(FhirResource::class);\n            if (!empty($resourceAttributes)) {\n                $attribute = $resourceAttributes[0]->newInstance();\n                $type      = $attribute->getResourceType();\n                $this->cache->cacheFHIRTypeMetadata($className, $type);\n\n                return $type;\n            }\n\n            // Check for complex type\n            $complexAttributes = $reflection->getAttributes(FHIRComplexType::class);\n            if (!empty($complexAttributes)) {\n                $attribute = $complexAttributes[0]->newInstance();\n                $type      = $attribute->typeName;\n                $this->cache->cacheFHIRTypeMetadata($className, $type);\n\n                return $type;\n            }\n\n            // Check for primitive type\n            $primitiveAttributes = $reflection->getAttributes(FHIRPrimitive::class);\n            if (!empty($primitiveAttributes)) {\n                $attribute = $primitiveAttributes[0]->newInstance();\n                $type      = $attribute->primitiveType;\n                $this->cache->cacheFHIRTypeMetadata($className, $type);\n\n                return $type;\n            }\n\n            // Check for backbone element - use element path directly\n            $backboneAttributes = $reflection->getAttributes(FHIRBackboneElement::class);\n            if (!empty($backboneAttributes)) {\n                $attribute = $backboneAttributes[0]->newInstance();\n                $type      = $attribute->elementPath;\n                $this->cache->cacheFHIRTypeMetadata($className, $type);\n\n                return $type;\n            }\n\n            $this->cache->cacheFHIRTypeMetadata($className, null);\n\n            return null;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheFHIRTypeMetadata($className, null);\n\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function isResource(object $object): bool\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getStructureTypeMetadata($className);\n        if ($cached !== null) {\n            return $cached === 'resource';\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n            $attributes = $reflection->getAttributes(FhirResource::class);\n            $isResource = !empty($attributes);\n\n            $this->cache->cacheStructureTypeMetadata($className, $isResource ? 'resource' : null);\n\n            return $isResource;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheStructureTypeMetadata($className, null);\n\n            return false;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function isComplexType(object $object): bool\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getStructureTypeMetadata($className);\n        if ($cached !== null) {\n            return $cached === 'complex-type';\n        }\n\n        try {\n            $reflection    = new \\ReflectionClass($object);\n            $attributes    = $reflection->getAttributes(FHIRComplexType::class);\n            $isComplexType = !empty($attributes);\n\n            $this->cache->cacheStructureTypeMetadata($className, $isComplexType ? 'complex-type' : null);\n\n            return $isComplexType;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheStructureTypeMetadata($className, null);\n\n            return false;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function isPrimitiveType(object $object): bool\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getStructureTypeMetadata($className);\n        if ($cached !== null) {\n            return $cached === 'primitive-type';\n        }\n\n        try {\n            $reflection  = new \\ReflectionClass($object);\n            $attributes  = $reflection->getAttributes(FHIRPrimitive::class);\n            $isPrimitive = !empty($attributes);\n\n            $this->cache->cacheStructureTypeMetadata($className, $isPrimitive ? 'primitive-type' : null);\n\n            return $isPrimitive;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheStructureTypeMetadata($className, null);\n\n            return false;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function isBackboneElement(object $object): bool\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getStructureTypeMetadata($className);\n        if ($cached !== null) {\n            return $cached === 'backbone-element';\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n            $attributes = $reflection->getAttributes(FHIRBackboneElement::class);\n            $isBackbone = !empty($attributes);\n\n            $this->cache->cacheStructureTypeMetadata($className, $isBackbone ? 'backbone-element' : null);\n\n            return $isBackbone;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheStructureTypeMetadata($className, null);\n\n            return false;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function extractFHIRVersion(object $object): ?string\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getFHIRVersionMetadata($className);\n        if ($cached !== null) {\n            return $cached;\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n\n            // Check all possible attribute types for FHIR version\n            $resourceAttributes = $reflection->getAttributes(FhirResource::class);\n            if (!empty($resourceAttributes)) {\n                $attribute = $resourceAttributes[0]->newInstance();\n                $version   = $attribute->fhirVersion;\n                $this->cache->cacheFHIRVersionMetadata($className, $version);\n\n                return $version;\n            }\n\n            $complexAttributes = $reflection->getAttributes(FHIRComplexType::class);\n            if (!empty($complexAttributes)) {\n                $attribute = $complexAttributes[0]->newInstance();\n                $version   = $attribute->fhirVersion;\n                $this->cache->cacheFHIRVersionMetadata($className, $version);\n\n                return $version;\n            }\n\n            $primitiveAttributes = $reflection->getAttributes(FHIRPrimitive::class);\n            if (!empty($primitiveAttributes)) {\n                $attribute = $primitiveAttributes[0]->newInstance();\n                $version   = $attribute->fhirVersion;\n                $this->cache->cacheFHIRVersionMetadata($className, $version);\n\n                return $version;\n            }\n\n            $backboneAttributes = $reflection->getAttributes(FHIRBackboneElement::class);\n            if (!empty($backboneAttributes)) {\n                $attribute = $backboneAttributes[0]->newInstance();\n                $version   = $attribute->fhirVersion;\n                $this->cache->cacheFHIRVersionMetadata($className, $version);\n\n                return $version;\n            }\n\n            $this->cache->cacheFHIRVersionMetadata($className, null);\n\n            return null;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheFHIRVersionMetadata($className, null);\n\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function extractParentResource(object $object): ?string\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getBackboneElementMetadata($className);\n        if ($cached !== null) {\n            return $cached->parentResource;\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n            $attributes = $reflection->getAttributes(FHIRBackboneElement::class);\n\n            if (empty($attributes)) {\n                $this->cache->cacheBackboneElementMetadata($className, null);\n\n                return null;\n            }\n\n            $attribute = $attributes[0]->newInstance();\n            $metadata  = new FHIRBackboneElementMetadata(\n                $attribute->parentResource,\n                $attribute->elementPath,\n                $attribute->fhirVersion,\n            );\n\n            $this->cache->cacheBackboneElementMetadata($className, $metadata);\n\n            return $metadata->parentResource;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheBackboneElementMetadata($className, null);\n\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function extractElementPath(object $object): ?string\n    {\n        $className = get_class($object);\n\n        // Check cache first\n        $cached = $this->cache->getBackboneElementMetadata($className);\n        if ($cached !== null) {\n            return $cached->elementPath;\n        }\n\n        try {\n            $reflection = new \\ReflectionClass($object);\n            $attributes = $reflection->getAttributes(FHIRBackboneElement::class);\n\n            if (empty($attributes)) {\n                $this->cache->cacheBackboneElementMetadata($className, null);\n\n                return null;\n            }\n\n            $attribute = $attributes[0]->newInstance();\n            $metadata  = new FHIRBackboneElementMetadata(\n                $attribute->parentResource,\n                $attribute->elementPath,\n                $attribute->fhirVersion,\n            );\n\n            $this->cache->cacheBackboneElementMetadata($className, $metadata);\n\n            return $metadata->elementPath;\n        } catch (\\ReflectionException) {\n            $this->cache->cacheBackboneElementMetadata($className, null);\n\n            return null;\n        }\n    }\n\n    /**\n     * Get the cache instance for testing or external access\n     */\n    public function getCache(): FHIRMetadataCache\n    {\n        return $this->cache;\n    }\n\n    /**\n     * Clear all cached metadata\n     */\n    public function clearCache(): void\n    {\n        $this->cache->invalidateCache();\n    }\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRMetadataExtractorInterface.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Interface for extracting FHIR metadata from PHP objects using attributes\n * and other metadata sources to support serialization decisions.\n *\n * @author Kiro AI Assistant\n */\ninterface FHIRMetadataExtractorInterface\n{\n    /**\n     * Extracts the FHIR resource type from a resource object.\n     *\n     * @param object $object The FHIR resource object to analyze\n     *\n     * @return string|null The resource type (e.g., \"Patient\", \"Observation\"), or null if not a resource\n     */\n    public function extractResourceType(object $object): ?string;\n\n    /**\n     * Extracts the FHIR type name from any FHIR object.\n     *\n     * @param object $object The FHIR object to analyze\n     *\n     * @return string|null The FHIR type name, or null if not determinable\n     */\n    public function extractFHIRType(object $object): ?string;\n\n    /**\n     * Determines if the given object is a FHIR resource.\n     *\n     * @param object $object The object to check\n     *\n     * @return bool True if the object is a FHIR resource, false otherwise\n     */\n    public function isResource(object $object): bool;\n\n    /**\n     * Determines if the given object is a FHIR complex type.\n     *\n     * @param object $object The object to check\n     *\n     * @return bool True if the object is a FHIR complex type, false otherwise\n     */\n    public function isComplexType(object $object): bool;\n\n    /**\n     * Determines if the given object is a FHIR primitive type.\n     *\n     * @param object $object The object to check\n     *\n     * @return bool True if the object is a FHIR primitive type, false otherwise\n     */\n    public function isPrimitiveType(object $object): bool;\n\n    /**\n     * Determines if the given object is a FHIR backbone element.\n     *\n     * @param object $object The object to check\n     *\n     * @return bool True if the object is a FHIR backbone element, false otherwise\n     */\n    public function isBackboneElement(object $object): bool;\n\n    /**\n     * Extracts the FHIR version from the object's metadata.\n     *\n     * @param object $object The FHIR object to analyze\n     *\n     * @return string|null The FHIR version (e.g., \"R4B\"), or null if not determinable\n     */\n    public function extractFHIRVersion(object $object): ?string;\n\n    /**\n     * Extracts the parent resource information for backbone elements.\n     *\n     * @param object $object The backbone element object to analyze\n     *\n     * @return string|null The parent resource type, or null if not a backbone element\n     */\n    public function extractParentResource(object $object): ?string;\n\n    /**\n     * Extracts the element path for backbone elements.\n     *\n     * @param object $object The backbone element object to analyze\n     *\n     * @return string|null The element path (e.g., \"Patient.contact\"), or null if not determinable\n     */\n    public function extractElementPath(object $object): ?string;\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRPrimitiveTypeMetadata.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Metadata container for FHIR primitive type information.\n *\n * @author Kiro AI Assistant\n */\nreadonly class FHIRPrimitiveTypeMetadata\n{\n    public function __construct(\n        public string $primitiveType,\n        public string $fhirVersion,\n        public bool $supportsExtensions = true\n    ) {\n    }\n}\n",
        "/fhir/Component/Serialization/src/Metadata/FHIRResourceMetadata.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata;\n\n/**\n * Metadata container for FHIR resource information.\n *\n * @author Kiro AI Assistant\n */\nreadonly class FHIRResourceMetadata\n{\n    public function __construct(\n        public string $resourceType,\n        public string $fhirVersion,\n        public ?string $profile = null\n    ) {\n    }\n}\n",
        "/fhir/Component/Serialization/src/Validator/FHIRSchemaValidator.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Validator;\n\nuse Ardenexal\\FHIRTools\\Component\\Serialization\\Exception\\ValidationException;\n\n/**\n * FHIR schema validator for validating FHIR XML against XSD schemas.\n *\n * This service provides XML schema validation capabilities for FHIR XML documents\n * against official FHIR XSD schemas.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRSchemaValidator\n{\n    /**\n     * Validate FHIR XML against its schema.\n     *\n     * @param string      $xmlData    The XML data to validate\n     * @param string|null $schemaPath Optional path to specific schema file\n     *\n     * @return array<string> Array of validation errors (empty if valid)\n     */\n    public function validateXml(string $xmlData, ?string $schemaPath = null): array\n    {\n        $errors = [];\n\n        try {\n            // Create DOMDocument for validation\n            $dom = new \\DOMDocument();\n            $dom->loadXML($xmlData);\n\n            // Determine schema path if not provided\n            if ($schemaPath === null) {\n                $schemaPath = $this->detectSchemaPath($xmlData);\n            }\n\n            // Validate against schema if available\n            if ($schemaPath !== null && file_exists($schemaPath)) {\n                libxml_use_internal_errors(true);\n\n                if (!$dom->schemaValidate($schemaPath)) {\n                    $xmlErrors = libxml_get_errors();\n                    foreach ($xmlErrors as $error) {\n                        $errors[] = sprintf(\n                            'Line %d: %s',\n                            $error->line,\n                            trim($error->message),\n                        );\n                    }\n                    libxml_clear_errors();\n                }\n            } else {\n                $errors[] = 'Schema file not found or not specified';\n            }\n        } catch (\\Exception $e) {\n            $errors[] = 'XML parsing error: ' . $e->getMessage();\n        }\n\n        return $errors;\n    }\n\n    /**\n     * Validate FHIR XML and throw exception if invalid.\n     *\n     * @param string      $xmlData    The XML data to validate\n     * @param string|null $schemaPath Optional path to specific schema file\n     *\n     * @throws ValidationException If validation fails\n     */\n    public function validateXmlOrThrow(string $xmlData, ?string $schemaPath = null): void\n    {\n        $errors = $this->validateXml($xmlData, $schemaPath);\n\n        if (!empty($errors)) {\n            throw new ValidationException('FHIR XML schema validation failed: ' . implode(', ', $errors));\n        }\n    }\n\n    /**\n     * Check if XML is well-formed (basic XML validation).\n     *\n     * @param string $xmlData The XML data to check\n     *\n     * @return array<string> Array of XML errors (empty if well-formed)\n     */\n    public function checkWellFormed(string $xmlData): array\n    {\n        $errors = [];\n\n        try {\n            libxml_use_internal_errors(true);\n\n            $dom = new \\DOMDocument();\n            if (!$dom->loadXML($xmlData)) {\n                $xmlErrors = libxml_get_errors();\n                foreach ($xmlErrors as $error) {\n                    $errors[] = sprintf(\n                        'Line %d: %s',\n                        $error->line,\n                        trim($error->message),\n                    );\n                }\n                libxml_clear_errors();\n            }\n        } catch (\\Exception $e) {\n            $errors[] = 'XML parsing error: ' . $e->getMessage();\n        }\n\n        return $errors;\n    }\n\n    /**\n     * Detect the appropriate schema path based on XML content.\n     */\n    private function detectSchemaPath(string $xmlData): null\n    {\n        // This would need to be implemented based on actual FHIR schema locations\n        // For now, return null to indicate schema detection is not implemented\n        return null;\n    }\n}\n",
        "/fhir/Component/Serialization/src/Validator/FHIRValidator.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Component\\Serialization\\Validator;\n\nuse Ardenexal\\FHIRTools\\Component\\Serialization\\Exception\\ValidationException;\nuse Ardenexal\\FHIRTools\\Component\\Serialization\\Metadata\\FHIRMetadataExtractorInterface;\n\n/**\n * FHIR validation service for validating FHIR objects against business rules.\n *\n * This service provides validation capabilities for FHIR objects beyond basic\n * serialization validation, including business rules and constraints.\n *\n * @author Kiro AI Assistant\n */\nclass FHIRValidator\n{\n    public function __construct(\n        private readonly FHIRMetadataExtractorInterface $metadataExtractor\n    ) {\n    }\n\n    /**\n     * Validate a FHIR object against its constraints.\n     *\n     * @param object               $fhirObject The FHIR object to validate\n     * @param array<string, mixed> $context    Validation context\n     *\n     * @return array<string> Array of validation errors (empty if valid)\n     */\n    public function validate(object $fhirObject, array $context = []): array\n    {\n        $errors = [];\n\n        // Basic structure validation\n        if (!$this->isValidFHIRObject($fhirObject)) {\n            $errors[] = 'Object is not a valid FHIR object';\n\n            return $errors;\n        }\n\n        // Resource-specific validation\n        if ($this->metadataExtractor->isResource($fhirObject)) {\n            $errors = array_merge($errors, $this->validateResource($fhirObject, $context));\n        }\n\n        // Complex type validation\n        if ($this->metadataExtractor->isComplexType($fhirObject)) {\n            $errors = array_merge($errors, $this->validateComplexType($fhirObject, $context));\n        }\n\n        // Primitive type validation\n        if ($this->metadataExtractor->isPrimitiveType($fhirObject)) {\n            $errors = array_merge($errors, $this->validatePrimitiveType($fhirObject, $context));\n        }\n\n        return $errors;\n    }\n\n    /**\n     * Validate a FHIR object and throw exception if invalid.\n     *\n     * @param object               $fhirObject The FHIR object to validate\n     * @param array<string, mixed> $context    Validation context\n     *\n     * @throws ValidationException If validation fails\n     */\n    public function validateOrThrow(object $fhirObject, array $context = []): void\n    {\n        $errors = $this->validate($fhirObject, $context);\n\n        if (!empty($errors)) {\n            throw new ValidationException('FHIR validation failed: ' . implode(', ', $errors));\n        }\n    }\n\n    /**\n     * Check if an object is a valid FHIR object.\n     */\n    private function isValidFHIRObject(object $object): bool\n    {\n        return $this->metadataExtractor->isResource($object)\n               || $this->metadataExtractor->isComplexType($object)\n               || $this->metadataExtractor->isPrimitiveType($object)\n               || $this->metadataExtractor->isBackboneElement($object);\n    }\n\n    /**\n     * Validate a FHIR resource.\n     *\n     * @param object               $resource The resource to validate\n     * @param array<string, mixed> $context  Validation context\n     *\n     * @return array<string> Validation errors\n     */\n    private function validateResource(object $resource, array $context): array\n    {\n        $errors = [];\n\n        // Check for required resourceType\n        $resourceType = $this->metadataExtractor->extractResourceType($resource);\n        if ($resourceType === null) {\n            $errors[] = 'Resource missing resourceType';\n        }\n\n        // Additional resource validation logic would go here\n\n        return $errors;\n    }\n\n    /**\n     * Validate a FHIR complex type.\n     *\n     * @param object               $complexType The complex type to validate\n     * @param array<string, mixed> $context     Validation context\n     *\n     * @return array<string> Validation errors\n     */\n    private function validateComplexType(object $complexType, array $context): array\n    {\n        $errors = [];\n\n        // Complex type validation logic would go here\n\n        return $errors;\n    }\n\n    /**\n     * Validate a FHIR primitive type.\n     *\n     * @param object               $primitiveType The primitive type to validate\n     * @param array<string, mixed> $context       Validation context\n     *\n     * @return array<string> Validation errors\n     */\n    private function validatePrimitiveType(object $primitiveType, array $context): array\n    {\n        $errors = [];\n\n        // Primitive type validation logic would go here\n\n        return $errors;\n    }\n}\n",
        "/fhir/bootstrap.php": "<?php\n\ndeclare(strict_types=1);\n\n/**\n * Minimal PSR-4 autoloader for php-wasm virtual filesystem.\n * Maps component namespaces to their VFS paths.\n */\nspl_autoload_register(function (string $class): void {\n    $prefixes = [\n        'Ardenexal\\\\FHIRTools\\\\Component\\\\FHIRPath\\\\' => '/fhir/Component/FHIRPath/src/',\n        'Ardenexal\\\\FHIRTools\\\\Component\\\\Serialization\\\\' => '/fhir/Component/Serialization/src/',\n        'Ardenexal\\\\FHIRTools\\\\' => '/fhir/src/',\n    ];\n\n    foreach ($prefixes as $prefix => $baseDir) {\n        $len = strlen($prefix);\n        if (strncmp($class, $prefix, $len) !== 0) {\n            continue;\n        }\n\n        $relativeClass = substr($class, $len);\n        $file = $baseDir . str_replace('\\\\', '/', $relativeClass) . '.php';\n\n        if (file_exists($file)) {\n            require $file;\n            return;\n        }\n    }\n});",
        "/fhir/src/Exception/FHIRToolsException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\nuse Exception;\n\n/**\n * Base exception class for all FHIR Tools related errors\n *\n * This abstract class provides a foundation for all FHIR Tools exceptions,\n * offering enhanced error context management and formatted error reporting.\n * All specific exception types should extend this class to maintain consistency\n * in error handling throughout the application.\n *\n * Features:\n * - Context information storage for debugging\n * - Formatted error messages with context\n * - Fluent interface for adding context data\n * - Consistent error structure across all FHIR Tools exceptions\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nabstract class FHIRToolsException extends \\Exception\n{\n    /**\n     * Additional context information about the error\n     *\n     * This array stores key-value pairs that provide additional context\n     * about the error, such as element paths, resource URLs, or other\n     * relevant debugging information.\n     *\n     * @var array<string, mixed>\n     */\n    protected array $context = [];\n\n    /**\n     * Construct a new FHIR Tools exception with optional context\n     *\n     * @param string               $message  The exception message\n     * @param int                  $code     The exception code\n     * @param \\Exception|null      $previous The previous exception for chaining\n     * @param array<string, mixed> $context  Additional context information\n     */\n    public function __construct(string $message = '', int $code = 0, ?\\Exception $previous = null, array $context = [])\n    {\n        parent::__construct($message, $code, $previous);\n        $this->context = $context;\n    }\n\n    /**\n     * Get additional context information about the error\n     *\n     * Returns the complete context array containing all additional\n     * information that was provided when the exception was created\n     * or added later via addContext().\n     *\n     * @return array<string, mixed> The context information\n     */\n    public function getContext(): array\n    {\n        return $this->context;\n    }\n\n    /**\n     * Add context information to the exception\n     *\n     * This method allows adding additional context information after\n     * the exception has been created. It uses a fluent interface\n     * pattern for easy chaining of multiple context additions.\n     *\n     * @param string $key   The context key\n     * @param mixed  $value The context value\n     *\n     * @return static Returns self for method chaining\n     */\n    public function addContext(string $key, mixed $value): static\n    {\n        $this->context[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * Get a formatted error message with context\n     *\n     * Returns the exception message along with a formatted representation\n     * of the context information. This is useful for logging and debugging\n     * as it provides all available information in a readable format.\n     *\n     * @return string The formatted message with context\n     */\n    public function getFormattedMessage(): string\n    {\n        $message = $this->getMessage();\n\n        if (!empty($this->context)) {\n            $contextString = json_encode($this->context, JSON_PRETTY_PRINT);\n            $message .= \"\\nContext: \" . $contextString;\n        }\n\n        return $message;\n    }\n}\n",
        "/fhir/src/Exception/GenerationException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\n/**\n * Exception thrown when FHIR code generation fails\n *\n * This exception is thrown when FHIR code generation encounters errors,\n * such as invalid StructureDefinitions, missing references, or unsupported\n * FHIR versions.\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nclass GenerationException extends FHIRToolsException\n{\n    /**\n     * Create exception for invalid StructureDefinition scenarios\n     *\n     * @param string $structureDefinitionUrl The URL of the invalid StructureDefinition\n     * @param string $reason                 The reason why it's invalid\n     *\n     * @return static\n     */\n    public static function invalidStructureDefinition(string $structureDefinitionUrl, string $reason): static\n    {\n        $message = \"Invalid StructureDefinition '{$structureDefinitionUrl}': {$reason}\";\n\n        return new static($message, 400, null, [\n            'structure_definition_url' => $structureDefinitionUrl,\n            'reason'                   => $reason,\n        ]);\n    }\n\n    /**\n     * Create exception for missing content reference scenarios\n     *\n     * @param string $contentReference The missing content reference\n     * @param string $elementPath      The element path where the reference was expected\n     *\n     * @return static\n     */\n    public static function missingContentReference(string $contentReference, string $elementPath): static\n    {\n        $message = \"Missing content reference '{$contentReference}' for element '{$elementPath}'\";\n\n        return new static($message, 404, null, [\n            'content_reference' => $contentReference,\n            'element_path'      => $elementPath,\n        ]);\n    }\n\n    /**\n     * Create exception for unsupported FHIR version scenarios\n     *\n     * @param string $fhirVersion The unsupported FHIR version\n     *\n     * @return static\n     */\n    public static function unsupportedFhirVersion(string $fhirVersion): static\n    {\n        $message = \"Unsupported FHIR version '{$fhirVersion}'\";\n\n        return new static($message, 400, null, [\n            'fhir_version' => $fhirVersion,\n        ]);\n    }\n\n    /**\n     * Create exception for invalid element path scenarios\n     *\n     * @param string $elementPath The invalid element path\n     *\n     * @return static\n     */\n    public static function invalidElementPath(string $elementPath): static\n    {\n        $message = \"Invalid element path '{$elementPath}'\";\n\n        return new static($message, 400, null, [\n            'element_path' => $elementPath,\n        ]);\n    }\n}\n",
        "/fhir/src/Exception/PackageException.php": "<?php\n\ndeclare(strict_types=1);\n\nnamespace Ardenexal\\FHIRTools\\Exception;\n\n/**\n * Exception thrown when package-related operations fail\n *\n * This exception is thrown when FHIR package operations encounter errors,\n * such as package not found, download failures, or invalid package formats.\n *\n * @author FHIR Tools\n *\n * @since 1.0.0\n */\nclass PackageException extends FHIRToolsException\n{\n    /**\n     * Create exception for package not found scenarios\n     *\n     * @param string $packageName The name of the package that was not found\n     * @param string $version     The version that was requested\n     *\n     * @return static\n     */\n    public static function packageNotFound(string $packageName, string $version = 'latest'): static\n    {\n        $message = \"Package '{$packageName}' version '{$version}' not found\";\n\n        return new static($message, 404, null, [\n            'package_name' => $packageName,\n            'version'      => $version,\n            'error_type'   => 'package_not_found',\n        ]);\n    }\n\n    /**\n     * Create exception for package download failures\n     *\n     * @param string $packageName The name of the package that failed to download\n     * @param string $version     The version that was requested\n     * @param int    $httpStatus  The HTTP status code from the failed request\n     *\n     * @return static\n     */\n    public static function downloadFailed(string $packageName, string $version, int $httpStatus): static\n    {\n        $message = \"Failed to download package '{$packageName}' version '{$version}' (HTTP {$httpStatus})\";\n\n        return new static($message, $httpStatus, null, [\n            'package_name' => $packageName,\n            'version'      => $version,\n            'http_status'  => $httpStatus,\n        ]);\n    }\n}\n"
    }
}